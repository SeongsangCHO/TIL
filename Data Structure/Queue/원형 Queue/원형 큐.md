## 원형 큐

- 배열의 마지막 인덱스에서, 다음 인덱스로 넘어갈 때, (index + 1) % 배열 사이즈 -> ex) 배열사이즈가 4이고 현재 삽입될 인덱스가 3이면, 계산을 통해 0인덱스로 접근 

- front와 rear가 같으면 큐는 비어있는 상태임
- rear + 1 을 MAX_SIZE로 나눈 나머지 값이 front와 같으면 큐는 꽉찬 상태 => rear가 front보다 1칸 이전일때를 의미하는 것 같음.

### 백준

- 10845

  - 큐의 기본내용 구현
  - 예외처리를 똑바로하지 않아서 에러가 있었음 -> 큐가 비어있을때를 정확히 파악하는 것이 중요했음.

- 18258

  - 위와 동일문제, 시간 제한

- 2164

  - 1,2,3,4...순서대로 쌓인 카드 덱에서 다음과 같은 행동을 반복한다

  - 제일 위에있는 1을 버리고, 그 다음 2를 맨밑에 놓는다.

  - 마지막 남은 카드를 구해라

  - 데이터 삽입 = push

  - 카드버리기 = deQueue

    - 현재 사이즈가 1이면 반환

  - 제일 밑에 놓기 =enQueue 

  - 로직

    - 1~N까지의 데이터를 갖는 큐를 생성
    - 현재 사이즈가 1이면 값 반환

    - 
    - else if 

- 1966 -해당문제는 힙 학습 후 구현하기로..

  - 우선순위 큐 구현[https://velog.io/@pa324/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-1xk1cw46t2](https://velog.io/@pa324/우선순위-큐-1xk1cw46t2)
    - 트리 구조 (최대힙을 이용해 구현)
    - 삽입의 위치를 찾기 위해 배열에 저장된 모든 데이터와 우선순위를 비교해야한다.
    - 
  - 첫째 줄, 케이스 수
  - 둘째, 각 문서의 수 N, 

  