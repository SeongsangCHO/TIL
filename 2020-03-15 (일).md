###### 1. 학습 날짜

- 2020-03-15(일)

---

###### 2. 학습시간

- 16:40 ~ 22:07 (자가)

---

###### 3. 학습 범위 및 주제

- printf 설계
---

###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---

###### 5. 학습 목표 

- pritnf설계
	
---

###### 6. 과제 제출 repository 주소

http://13.125.198.2:3000/secho/ft_printf.git

---

###### 7. 상세 학습 내용

- 코드작성시간 : 2시간 


- ### printf 옵션

**사용법**

- %flag width .precision type

1. 형식 문자열에 사용하는 형식은, 출력할 값에 대해 각각 적용됩니다. 출력할 값이 세개라면 %문자 또한 세 번 나와야 합니다.
2. 형식 지정의 첫 번째 문자는 반드시 % 문자여야 합니다. %문자는 형식 지정에 사용하는 특수 문자로, %문자를 출력해야 한다면 두 번을 중복시켜서 %%와 같이 사용합니다.
3. []로 둘러싸인 부분은 옵션이므로 생략할 수 있습니다. 따라서, 최소한의 형식 지정은 %와 type으로 구성됩니다.
4. 각각의 옵션이 등장하는 순서는 반드시 지켜야 하고, 여러 개의 옵션을 함께 사용할 수 있습니다



- %#23.11x
  - "#" : 8, 16진수 출력에서 공백대신 0또는 0x출력
  - x : 16진수 출력
  - 23 => 현재문자 + 공백문자 포함해서 23칸 , 왼쪽부터 ex 출력문자가 5문자이고 숫자가 7이면 ^^12345 이렇게 ^^는 공백2문자
  - .11 소수점부분 11자릿수가 될 때까지 나머지부분 0으로 채우기

**flags**

1. 출력할 값의 앞에 표시할 문자를 설정하는 영역
2. 옵션이기 때문에 생략할 수 있습니다.
3. 여러 개의 플래그를 동시에 사용할 수 있습니다.



```c
print("[%+-6d]", 123 ); // [+123  ] - 부호 +왼쪽 정렬
```

4. 기호

| 기호    | 설명                                               | 코드                                               | 출력             |
| ------- | -------------------------------------------------- | -------------------------------------------------- | ---------------- |
| -       | 왼쪽 정렬. 기본 값은 오른쪽 정렬                   | printf( “[%6d]\n”, 123);printf( “[%6d]\n”, -123);  | [ 123][-123 ]    |
| +       | + 또는 – 기호 추가                                 | printf( “[%+d]\n”, 123);printf( “[%+d]\n”, -123);  | [+123][-123]     |
| 0(zero) | 앞자리에 공백 대신 0 추가                          | printf( “[%06d]\n”, 123);printf( “[%06d]\n”,-123); | [000123][-00123] |
| (공백)  | 양의 정수일 경우, + 기호를 출력하는 대신 공백 추가 | printf( “[%+d]\n”, 123);printf( “[% d]\n”, 123);   | [+123][ 123]     |
| #       | 8진수와 16진수 출력에서, 공백 대신 0 또\는 0x 출력 | printf( “[%#o]\n”, 123);printf( “[%#x]\n”, 123);   | [0173][0x7b]     |



**width**

1. 출력할 값의 최소 너비를 지정합니다.

2. 출력할 값이 지정한 너비보다 작으면 자릿수를 맞추기 위해 공백 또는 0을 채워 넣습니다. 출력할 값이 너비보다 클 경우에는, 값이 잘리는 일은 있을 수 없으므로 width옵션은 무시됩니다.

3. 예제

   

4. ```c
   printf("[%6d]\n",   123);  // [   123] - 공백+오른쪽 정렬+10진수
   printf("[%06d]\n", 123);  // [000123] - 0+오른쪽 정렬+16진수
   printf("[%-6d]\n",  123);  // [123   ] - 공백+왼쪽 정렬+10진수
   printf("[%06x]\n", 123);  // [00007b] - 공백+왼쪽 정렬+16진수
   
   ```

   

**percision**

1. 출력할 값의 정확도를 위한 최대 자릿수를 설정합니다.

2. 출력할 값이 정수라면 최대 자릿수를 맞추기 위해 0을 추가합니다. 자릿수가 출력할 값보다 작을 경우에는 값을 자르거나 하지 않고 값을 모두 출력합니다. 이 옵션은 flags와 width옵션을 결합해서 같은 결과를 얻을 수 있습니다.

3. 출력할 값이 실수라면 소수점 이하의 최대 자릿수를 가리키고, 자릿수에 따라 반올림이 되거나 소수점 이하에 0이 추가됩니다. 실수 전체의 자릿수 설정은 width옵션을 사용합니다.

4. 예제



```c
printf("[%.6d]\n", 123  );   // [000123]
printf("[%.2f]\n", 123.456);   // [123.46]
printf("[%.2f]\n", 123.454);   // [123.45]
printf("[%f]\n", 123.454);    // [123.454000] //
printf("[%.6f]\n", 123.454);   // [123.454000]//뒷자리 6자리 000붙임
printf("[%013.6f]\n", 123.454); // [000123.454000] //뒷자리 6자리 만들고 총 13자리가 맞을 때 까지 앞에서 0으로 채움
```

**type**

1. 숫자(number), 문자(character), 문자열(string) 중의 하나
2. 숫자는 정수와 실수로 나누어지고, 정수는 다시 부호 있는 정수와 부호 없는 정수로 나누어집니다.
3. 정수는 8진수, 10진수, 16진수 형태로 출력할 수 있고, 실수는 일반적인 표기법 이외에 지수(exponent) 표기법으로 출력할 수 있습니다.
4. 타입 문자

| 기호 | 설명                                   | 코드                                                    | 출력                            |
| ---- | -------------------------------------- | ------------------------------------------------------- | ------------------------------- |
| c    | 문자                                   | printf(“[%3c]\n”, ‘A’);printf(“[%-3c]\n”, ‘A’);         | [ A][A ]                        |
| s    | 문자열                                 | printf(“[%5s]\n”, “ABC”);printf(“[%-5s]\n”, “ABC”);     | [ ABC][ABC ]                    |
| d    | 부호 있는 10진수                       | printf(“[%d]\n”, 123);printf(“[%d]\n”, -123);           | [123][-123]                     |
| u    | 부호 없는 10진수                       | printf(“[%u]\n”, 123);printf(“[%u]\n”, -123);           | [123][4294967173]               |
| o    | 부호 없는 8진수                        | printf(“[%5o]\n”, 123);printf(“[%05o]\n”, 123);         | [ 173][00173]                   |
| x, X | 부호 있는 16진수                       | printf(“[%5x]\n”, 123);printf(“[%05X]\n”, 123);         | [ 7b][0007B]                    |
| p    | 주소를 16진수로 출력                   | int N = 123;printf(“[%p]\n”, 123);printf(“[%p]\n”, &N); | [0000007B][0012FED4]            |
| e, E | 지수 형식(d.dddd e +ddd)으로 실수 출력 | printf(“[%e]\n”, 123.4567);printf(“[%E]\n”, -123.4567); | [1.234567e+002][-1.234567E+002] |
| f    | 고정 형식(dddd.dddd)으로 실수 출력     | printf(“[%f]\n”, 123.4567);printf(“[%f]\n”, -123.4567); | [123.456700][-123.456700]       |
| g, G | f와 e 형식 중에서 짧은 형식 선택       | printf(“[%g]\n”, 123.4567);printf(“[%G]\n”, -123.4567); | [123.457][-123.457]             |



### 과제설계

- %flag width .precision type 순서로 와야함
- 유효성 검사 - 
- 1. % 다음 문자부터 서식지정자를 만날때 까지 들어올 수 있는 내용이 포함되어 있는지 여부 파악- define으로 모든 문자를 정의하여 문자열쪼개 비교
- 2. width전까지 - (0을 제외한 - flag에 0이 포함되어 있으므로, 1~9까지)를 만나기전 까지 flag로만 이루어져 있는지?
- 3. precision전까지 (. 과 숫자), .을 만나기전 까지 숫자로만 이루어져 있는지?
- 4. 서식지정자전까지 숫자로만 이루어져 있는지?
- 5. 서식지정자 1글자만 읽기
- 만들어진 구조체로 flag, width, precision, type순서로 문자열 생성하기
- 출력
- 이라는 순서로 설계를 했다.
- 첫째로 진행해야할 부분은 1번, %다음문자부터 서식지정자를 만날때 까지 올 수 있는 내용이 포함되어 있는지 여부를 파악하는 것이다. => false일시 return 0으로 함수를 종료. 21:49분 ~
- 
- 
---
###### 8. 학습 내용에 대한 개인적인 총평

-  설계부터 다시 시작하면서 몰랐던 것들을 다시 신경쓸 수 있게 되었다.
-  유효성검사는 생각지도 않았던 부분이었는데, 이 부분을 신경쓰지 못했다는 것이 말이 안되었던 것 같다.
-  정해진 순서가 있고, 옵션의 갯수도 정해져있기때문에 꼼꼼히만 작성한다면 구현할 수 있을 것 같다.
-  처음과 달리 어느 정도 고민도해보고 자료도 많이 찾아보았기 때문에 이전보다 막막함은 조금이나마 덜 수 있었다.
-  생각보다 규모가 있어서 시간은 조금 더 걸릴 것 같다.

---

###### 9. 다음 학습 계획 (최소 5줄 이상)

- ft_printf 설계
- ft_printf 구현
- ft_printf 코드 참고 및 정리
- 동료들과 코드비교 및 오류처리방법 토의
- 여러 테스트케이스를 만들어 생각하지 못한 예외처리를 할 것.