### [NestJS로 배우는 백엔드프로그래밍 4장](https://wikidocs.net/158499)


> 비즈니스로직을 처리하는 프로바이더


#### 프로바이더
`@Injectable` 데코레이터가 달린 대부분의 비즈니스로직, 데이터처리를 담당하는 클래스.


#### 모듈
프로바이더와 컨트롤러를 엮어 단위로 만듦.
생성한 모듈은 루트모달과 연결되어야하며, 기능을 최대한 분리해서 모듈로 만드는게 좋음
`@Module()` 데코레이터는 객체를 인자로 받는데, 프로퍼티는 다음과 같음
- `providers` : 현재 모듈에서 공유될 providers
- `controllers` : 현재 모듈에 정의된 Controllers
- `imports` : providers들을 export한 모듈의 집합
- `exports` : 다른 모듈에서 사용할 수 있어야하는 providers

`nest g mo ${module_name}` 하면 알아서 등록해줌

[모듈에 관한 자세한 포스팅](https://tristy.tistory.com/43)
<br/>

```ts
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}
    ...

    @Delete(':id')
    remove(@Param('id') id: string) {
      return this.usersService.remove(+id);
    }
}

```
- Controller는 비즈니스로직을 수행하지 않는다.
- Controller는 주입받은 userService에게 작업을 위임한다.

<br/>

```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
    ...

  remove(id: number) {
    return `This action removes a #${id} user`;
  }
}
```
- `@Injectable` 가 선언된 클래스는 다른 컴포넌트에 주입할 수 있는 "프로바이더"가 된다.

프로바이더는 모듈에도 등록해주어야한다..는데 모듈은 갑자기 어디서 등장한 거 ?




### 모듈
- 각 app은 적어도 하나의 모듈을 가진다. root Module은 nest app gragh를 build하는데 사용하는 시작점.
