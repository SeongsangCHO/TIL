---
###### 1. 학습 날짜

- 2020-03-09(월)
 
---
###### 2. 학습시간

- 12:00 ~ 21:36 (자가)

---
###### 3. 학습 범위 및 주제

-  인프런 스프링프레임워크 강의 4강씩 수강 및 정리, printf 동작원리

---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스프링프레임워크 학습 및 printf정리

---
###### 6. 과제 제출 repository 주소

http://13.125.198.2:3000/secho/ft_printf.git

---
###### 7. 상세 학습 내용

- 코드작성시간 : 5시간 
- ### 웹 프로그래밍 설계 모델

웹서비스 동작과정 https://gmlwjd9405.github.io/2018/10/28/servlet.html

#### Model 1

- 사용자로부터 리퀘스트를 처리하는 기능(Service,Dao), 보여줄 뷰 (JSP)를 하나에 담음.
- HTML안에다가 java 등을 넣기 떄문에 개발속도가 빠름
- 여러 언어를 한 문서에 작성하면 유지보수가 힘듬

클라이언트 (브라우저를 이용한)가 요청(리퀘스트)을 함

WAS(웹 어플리케이션 서버)에서 요청한 것을 처리를 함

데이터베이스에서 요청을 받아 정보를 던져줌

WAS에서 다시 해당 정보를 Response해줌

#### Model2 => mvc를 기본

- controller (하위들을 컨트롤)
- service (기능)
- dao (db연동)
- view (사용자에게 보여줄 jsp)
- 각 기능을 모듈로 구분하여 개발하면 유지보수가 수월해짐.

                       view(jsp)
    
                         l

리퀘스트 -> controller(어느 서비스를 사용할지)-> Service ->  Dao <-> Model <-> 데이터베이스

### 스프링 MVC프레임워크 설계 구조

![스프링 MVC설계구조](https://user-images.githubusercontent.com/55486644/76188505-90ba7800-621b-11ea-9109-0b4d27207343.JPG)

1. 리퀘스트를 받은 DispatcherServlet가 HandlerMapping을 호출, 핸들러매핑은 여러 컨트롤러중에 가장 적합한 컨트롤러를 선택해주는 것 ~~좀 추상적인가~~
2. DispatcherServlet가 HandlerAdapter --> 컨트롤러중 가장 적합한 메소드를 선택 => 수행한 결과를 Model로 데이터를 DispatcherServlet로 전해줌.
3. DispatcherServlet가 ViewResolver (처리결과를 출력할 view를 선택) -> 컨트롤러부터 받은 Model을 출력할 jsp뷰를 선택해줌.
4. View(jsp)를 이용해 응답을 생성한 후 , 클라이언트에게 응답을 전해준다.

#### DispatcherServlet 

- Spring Container를 생성한다.
  Spring Container: Controller의 lifecycle 관리
  https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html

- web.xml에 서블릿을 매핑 ~~web.xml에 대한 학습 필요 jsp,servlet~~ 참고 https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html

스프링프레임워크에 있음.



##### Controller 객체 @RequestMapping

- 사용자로부터 받은 요청을 특정문자로 매핑시켜 해당 메소드를 수행할 수 있도록 하는 것

  

![Spring 응답처리 단계](https://user-images.githubusercontent.com/55486644/76189896-1855b600-621f-11ea-9f55-975d35674af5.JPG)

1. 사용자요청 -> DS (핸들러 매핑)이 컨트롤러를 찾음
2. 적합한 메소드를 찾기 시작함 -> @RequestMapping을 이용해 찾을 수 있음
3. 메소드를 찾아서 해당 부분 실행 ->Service, Dao, DB-> Model 반환
4. DS는 가장 적합한 뷰를 찾음 
5. 사용자에게 View로 응답함. 
6.      
- ### 생명주기

- 스프링컨테이너 초기화 = 빈 객체 생성 및 주입

- 스프링컨테이너 종료 = 빈 객체 소멸

- 빈 객체의 생명주기 = 스프링 컨테이너 생명주기

- ```java
  public class BookRegisterService implements InitializingBean, DisposableBean
  {
  	@Override
  	public void afterPropertieSet() throws Exception
  	//bean 객체 생성...
  }
  @Override
  	public void destroy() throws Exception
  	...//bean 객체 소멸
  ```

  bean객체 생성, 소멸할 때 호출되는 함수들이 존재함. 이를 이용해서 해당 시점에 맞춰서 기능을 추가할 수 있음.

- ```xml
  <bean id = "registerService" class="packagename"
  init-method ="initMethod"
  destroy-method="destroyMethod"/>
  ```

  ```java
  public void initMethod()
  {
  	//객체 생성 단계
  }
  public void destroyMethod()
  {
  	//객체 소멸 단계
  }
  ```

  

### XML파일 대신 java(어노테이션 이용)로 스프링설정

@Configuration 어노테이션으로 xml파일을 java에서 대신할 수 있도록 사용

xml에서의 bean등록은 java에서 객체 생성

```java
@Configuration
public class MemberConfig(){
	@Bean
	public StudentDao studentDao(){
		return new StudentDao();
	}
}// = > xml에서 bean등록과 같음
//의존 주입은
	@Bean
	public StudentService Service(){
		return new StudentService(studentDao());
	}//생성자주입 ref= studentDao일때.
//프로퍼티로 존재하는 것은 객체 생성을 하고 이에 맞게 설정.
	@Bean
	public DBConnectionInfo dBConnectionInfoDev(){
		DBConnectionInfo inforDev = new DBConnectionInfo();
        inforDev.setJdbcUrl("Value");
        inforDev.setUserId("Value");
        inforDev.setUserPw("Value");
		return inforDev;
    }
```

xml을 이용할 때는 GenericXmlApplicationContext를 이용했지만 어노테이션을 이용할 때

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(자바파일.class, 파일2.class, 파일3.class); //로 이용한다
```

xml도 여러개로 분리했던 것 처럼 java도 분리할 수있음.

파일2, 파일3.class 대신에 이를 한꺼번에 불러오기 위해선

파일1내에서 @Import를 사용.

```java
@Import({파일2.class, 파일3.class})
```
### 가변인수함수

- 인수의 갯수와 타입이 미리 정해져 있지 않다.

- int printf( const char *format, ... ) format은 서식 문자열이라고 하고 ...이라는 생략기호는 인수 갯수,타입을 점검하지 않도록 한다. 이 기호에 의해 가변 인수가 가능해진다.

- 컴파일러는 ...이후의 인수에 대해서 갯수나 타입을 상관하지 않는다.

  

#### 구조(stdarg.h에 정의되어 있는 애들.)

```c
void VarFunc(int Fix, ...)
{
   va_list ap;// va_list 타입은 char *으로 정의되어있다.
   va_start(ap,Fix);//Fix는 마지막 고정인수. 고정인수 다음번지로 ap를 맞추어 준다.
   while (모든 인수를 다 읽을 때까지) {
      va_arg(ap,인수타입);//가변인수를 실제로 읽는 명령, ap번지에 있는 값이 어떤 타입인지 알아야하므로, ap위치에 타입에 맞는 값을 읽어 리턴해주고, ap를 다음 가변인수로 옮겨준다. 반복적 호출을 하면 가변 인수를 순서대로 읽을 수 있다.타입이름이 어떻게 함수 인수로 전달될수있는가? =>va_arg는 매크로함수이기때문에, 내부적으로 sizeof연산자, 캐스트 연산자로 전달되기 떄문에 타입명이 될 수 있는 것이다.
   }
   va_end(ap);//가변 인수를 다 읽은 후 뒷정리, 없어도 지장이 없다. 호환성 때문에 있는 것. 플랫폼에 따라 읽은 후 뒷처리를 해주어야할 필요가 있기 때문이다.
}
//[출처] https://blog.naver.com/jangbalam99/10026018889
```

### 가변인수 함수의 조건

- 반드시 하나 이상의 고정 인수를 가져야 한다. 가변 인수를 읽기위한 포인터 ap를 초기화하기 위해 마지막 고정 인수의 번지를 알아야하기 때문이다.
- va_start는 마지막 고정인수의 번지에 길이를 더해 가변 인수가 시작되는 번지를 계산한다.





### design

- format을 저장해두는 문자열(str)
- %만나기전까지 format write로 1바이트로 출력해주다가 %를 만났을 때, 이에 해당하는 로직생성, (str=+2). va_arg(ap, 인수타입)

---
###### 8. 학습 내용에 대한 개인적인 총평

- 가변인수함수, 스프링에 대해 학습했다. printf를 구현하기 위해서 정말 많은 노력을 쏟아야할 것 같다는 생각이 들었다. 그 이유는 일단 지원하는 자료형이 다양하고 각 자료형마다 함수를 만들어주어야하기 때문이다. 또 소수점 등 고려할 것이 한 두군데가 아니라 일주일동안 해당과제에 대해 집중해야할 것 같다. 스프링도 진도에 맞추어 끝내고 mysql workbench이외로 게시판을 하나 작성하려고 한다. 작성기간은 2일로 해당 과제와 병행하며 진행할 계획이다. 그리고 백준이나 swea에서 하루에 3문제정도는 풀어야겠다. 알고리즘공부도 차츰해나갈 계획을 세웠다. 각 문제는 자바로 풀 예정이다.
알고리즘, printf, spring과제를 이번주동안 열심히 진행할 것이다.

---
###### 9. 다음 학습 계획 (최소 5줄 이상)

- ft_printf 내용정리
- 백준 및 swea문제 풀기
- 인프런 스프링프레임워크 강의 4강씩 수강 및 정리
- 동료들과 코드비교 및 오류처리방법 토의
- 여러 테스트케이스를 만들어 생각하지 못한 예외처리를 할 것.