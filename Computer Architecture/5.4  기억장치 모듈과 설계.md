### 5.4  기억장치 모듈과 설계

---



메인 메모리 RAM, ROM와 CPU간에 데이터를 주고받을 수 있게하기 위해서 메인메모리에 Data, Address, Control bus를 연결하는 방식을 알아본다.



- 원하는 만큼의 기억장치 용량을 가지게 하기 위해서 여러 칩을 사용

- 칩의 각 기억장소에 저장되는 비트 수는 일반적으로 컴퓨터의 단어 길이보다 적기 때문에, 한 번에 한 단어씩 액세스 하기 위해서 여러 칩을 **병렬**접속 해야한다.
- 여러 칩의 병렬접속으로 만들어지는 기억장치 모듈에 대한 설계 방법을 알아본다



설계 방법은 5가지.

A(기억장치 용량) * B(데이터 비트 수)

A를 구성하는 2^n에서 n승이 어드레스 라인 수 



### 1. 기억장치 칩의 데이터 비트수가 컴퓨터 단어 길이보다 짧은 경우



컴퓨터 단어길이가 N비트, 기억장치의 입출력 비트수가 B일 때, 한 번에 한 단어씩 데이터 액세스를 하기 위해서 **N / B**개의 칩들로부터 동시에 `B`비트씩 엑세스 해야함.



예를들어 단어길이가 `8bit`고, 기억장치는 `16 x 4bit`라고 했을 때 주소 버스는 4bit, 한번에 출력되는 데이터는 `4bit`다. 그럼 한 번에 4bit밖에 전달하지 못하므로, 두개의 칩을 사용해 8비트를 전달하도록 한다.



![](https://images.velog.io/images/secho/post/a15ac0ea-7fe3-4f7d-869b-e41fc1ee4d4e/image.png)

- 칩셀렉터를 공유하고, 주소버스 4비트에 있는 데이터를 2개의 칩이 받아서 데이터버스에 총 8비트씩 입, 출력시킬 수 있다.



#### 1.1 추가적 예제

[예제] 1K * 8Bits RAM Chip을 이용한 1K * 32Bits Main Memory Module Design

- 같은 주소버스를 공유하는 4개의 칩을 연결하면 됨. 한 칩당 8비트씩 총 32비트를 전달할 수 있음.
- 2^10의 주소공간을 가져서 00 0000 0000 ~ 3 F F까지 주소공간이 있을 수 있음





### 2. 기억장치 용량이 각 기억장치칩의 용량보다 큰 경우

어드레스 용량이 커져야함.

기억장치용량 = 데이터를 저장하는 용량

- [예] 두 개의 (16) * 4비트 RAM칩들을 이용한 (32) * 4비트 기억장치 모듈 설계

- 여러개의 칩을 직렬로 접속해 기억장치 모듈을 구성



16 * 4 의 램칩을 직렬로 접속 = > 32 * 4가됨. 

직렬 병렬간의 차이는 앞에다 곱하냐, 뒤에다 곱하냐로 구분할 수 있음.

직렬 2 * (16 * 4)  => 2^5 * 4 =>입력주소 5개 출력 4비트

병렬 (16 * 4) * 2 => 2^4 * 8 => 입력주소 4개 , 출력 8비트









![](https://images.velog.io/images/secho/post/8cd096f7-2220-43e3-9f74-4bb69ed55e13/image.png)

- 두개 RAM 칩들을 직렬접속한 예
- A4, 최상단비트가 0,1로 들어오며 이 비트는 칩셀렉터로서 사용한다.
- A4(CS) + A3 ~ A0(공통적)선택된 칩의 주소에 따라 해당하는 데이터를 전달한다. 
- 최상단비트를 CS로 사용
  - 1,0이냐에 따라서 상위, 하위 16비트로 나뉜 칩을 선택함
  - 1비트 확장된 효과
  - 상위 [0]0000 ~ [0]1111 => [0] CS
  - 하위 [1]0000 ~ [1]1111 => [1] CS



#### 2.1 추가적인 예제

1K * 8bit RAM 칩들을 이용해 4K * 8bit를 구성해보자

![](https://images.velog.io/images/secho/post/7a973de9-316d-4f1c-896f-9013d5ed564c/image.png)

=> 4개의 RAM칩을 직렬구성 4 * (1K * 8bit)

- 4K는 2^12, 4096의 기억장소수를 갖게됨
- 1K칩은 2^10개씩의 기억장소가 있으므로 하위 10bit는 공통 접속해야하고, 4개의 RAM칩을 구분하기 위한 CS 신호를 발생시켜야하므로 주소비트중 최상위 2개의 비트를 2 * 4 디코더로 사용해 4개의 CS신호를 발생시킨다.
- 주소공간이 연결된 것과 같은 효과를 얻을 수 있음 000~~FFF







### 5.4 기억장치 모듈의 설계　	`secho`

**1번 다음은 n * m 크기의 메인메모리 모듈을 디자인한 그림입니다. 각 빈칸에 대해서 알맞게 채워주세요.**

<br>

![](https://images.velog.io/images/secho/post/8cd096f7-2220-43e3-9f74-4bb69ed55e13/image.png)

<br>

- 주소버스 `_`개, 데이터 입출력 비트가 `_`개인  `_ * _bits` 크기의 RAM Chip들을 `직렬 / 병렬`접속으로 `_ * _bits` 크기의 메인메모리를 디자인했다.

<br>



![](https://images.velog.io/images/secho/post/a15ac0ea-7fe3-4f7d-869b-e41fc1ee4d4e/image.png)

<br>

- 주소버스 `_`개, 데이터 입출력 비트가 `_`개인  `_ * _bits` 크기의 RAM Chip들을 `직렬 / 병렬`접속으로 `_ * _bits` 크기의 메인메모리를 디자인했다.

<br>

**2번 [연습문제 5.4]**

<br>

**다음과 같은 조직을 가진 RAM들을 이용하여 1K * 32비트 기억장치 모듈을 구성하는데 필요한 칩의 수를 구하라**

<br>

(1) 512 * 1비트 조직 :  

(2) 128 * 4비트 조직 : 

(3) 64 * 8비트 조직 : 



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary><br>
1번

다음은 n * m 크기의 메인메모리 모듈을 디자인한 그림입니다.

각 빈칸에 대해서 알맞게 채워주세요.

![](https://images.velog.io/images/secho/post/8cd096f7-2220-43e3-9f74-4bb69ed55e13/image.png)



주소버스  `4`개 데이터 입출력 비트가 `4`개인 `16 * 4bit`크기의 RAM Chip들을 `[직렬] / 병렬`접속으로 `32 * 4bit` 크기의 메인메모리를 디자인했다.

- 각 RAM은 4개의 비트로 기억장소의 위치를 결정한다.
- 한 램은 총 16개씩 0000 ~ 1111까지 가질 수 있지만 두 RAM을 직렬접속하면 최상단비트를 칩셀렉터로 사용해 1bit 증가된 효과를 얻을 수 있다.
- 상위비트를 0,1로 set하면 00000 ~ 01111, 10000 ~ 11111까지 선택할 수 있으므로, 총 32개의 주소를 선택해 데이터 입출력을 할 수 있다.







![](https://images.velog.io/images/secho/post/a15ac0ea-7fe3-4f7d-869b-e41fc1ee4d4e/image.png)

주소버스 `4`개, 데이터 입출력 비트가 `4`개인  `16 * 4bits` 크기의 RAM Chip들을 `직렬 / [병렬]`접속으로 `16 * 8bits` 크기의 메인메모리를 디자인했다.

- 컴퓨터 워드는 8bit인데 RAM크기가 4bit일때 두개의 RAM을 병렬접속하여 8비트 입출력크기를 만들 수 있다. 
- 칩셀렉터를 공유하고, 주소버스 4비트에 있는 데이터를 2개의 칩이 받아서 데이터버스에 총 8비트씩 입, 출력시킬 수 있다.





2번 [연습문제 5.4]



**다음과 같은 조직을 가진 RAM들을 이용하여 1K * 32비트 기억장치 모듈을 구성하는데 필요한 칩의 수를 구하라**

- 1K * 32는 기억장소가 2^10, 데이터 입출력이 32비트를 가짐.

- 앞으로 곱 = 직렬 ,뒤로 곱 = 병렬

(1) 512 * 1비트 조직 :  2개의 직렬연결 2 * (512) => 1K * 1bits => 뒤로 32개 병렬연결 (1K * 1bits) * 32 => 1K * 32bits

(2) 128 * 4비트 조직 : 8개의 직렬연결 8 * (128), 8개의 병렬연결 (4) * 8

(3) 64 * 8비트 조직 :  16개의 직렬연결 16 * (64), 4개의 병렬연결 (8) * 4



</details>
<br><br>

