###### 1. 학습 날짜

- 2020-03-14(토)

---

###### 2. 학습시간

- 17:00 ~ 01:22 (자가)

---

###### 3. 학습 범위 및 주제

- Makefile 작성
---

###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---

###### 5. 학습 목표 

- Makefile 작성
	
---

###### 6. 과제 제출 repository 주소

http://13.125.198.2:3000/secho/ft_printf.git

---

###### 7. 상세 학습 내용

- 코드작성시간 : 2시간 

#### Makefile 옵션
- $@	목표 이름 
- $*	목표 이름에서 확장자가 없는 이름
- $<	조건 파일 중 첫번째 파일
- $?	목표 파일 보다 더 최근에 갱신된 파일 이름
        문법

- $(addprefix  접두어, 문자열 )  ex) $(addprefix src/, memo main) => src/memo     src/main

- - ~~해당 명령어를 이용해 오브젝트파일을 objs/하위에 생성하고 싶다.~~ 안되는듯.?

#### Makefile 순서

 예제 
CC = gcc
OBJS = MySocket.o MyClient.o
TARGET = MyClient

.SUFFIXES : .c .o

all : $(TARGET)

$(TARGET): $(OBJS)
	   $(CC) -o $@ $(OBJS)

clean :
      rm -f $(OBJS) $(TARGET)
      
- 변수, 규칙들을 구성한다 = CC LIBS OBJS SRCS 등 all, clean 규칙들이 정의됨
- Makefile에서 첫 번째로 만나는 규칙, 즉 all을 처리, all은 $(TARGET), 즉 MyClient라는 파일이 졶재하지 않으므로 **선행조건은 만족되지 않은 것**으로 make는 $(TARGET)규칙을 찾아 먼저 처리, TARGET는 OBJS를 선행조건으로 가지므로, 같은 방시으로 OBJS 규칙을 찾아 처리하려함
- $(OBJS)는 My..*.o이므로 make는 *.o 규칙이 있는지 찾아본다. .SUFFIXES : .c .o 알아서 c파일이 o파일로 컴파일되게 처리해줌
- $(OBJS)가 만족되므로 $(TARGET)선행조건도 만족,  $(CC) -o $@ $(OBJS) 수행
- $@는 $(TARGET)랑 동일.
- addprefix를 사용해서 path를 지정해주었지만 현재파일에 오브젝트파일이 생성되는 이유를 찾지 못했다.
- 


출처: https://kwangja.tistory.com/entry/Makefile-내에서-사용되는-문법-정리 [광자의 세상살이]

https://www.joinc.co.kr/w/Site/C/Documents/minzkn_make
---
###### 8. 학습 내용에 대한 개인적인 총평

- 하나의 make로 다시 makefile을 호출하여 .a파일 생성하는 것은 했지만, 다른 디렉토리에 있는 .c파일을 컴파일하여 해당 디렉토리에 오브젝트파일을 만드는 방법은 해결하지 못했다. makefile작성은 할 줄 알았으나 원하는 기능구현을 하는데 차질이 있게 되었다.
- addprefix를 통해 경로설정을 해주었지만, 현재 디렉토리에 오브젝트가 생성될 뿐 문제가 해결되지는 않았다.
- 사소한 부분을 해결하지 못하니 답답하다 조금 더 여유를 가지고 많은 자료들을 정리해야할 것 같다.
- 구글로 참고사이트를 많이 찾아보았지만 해당 부분을 구현 또는 설명한 자료를 아직 찾지 못했다. 더 다양한 검색키워드로 접근해야 해결할 수 있을 것 같다. 당분간 백준 문제풀이는 우선순위에서 밀고 해당 과제에 전념해야겠다.

=> obj파일 경로를 지정한 후 , $(OBJ): %.o: %.c .. OBJ를 만들기 위해서 , 모든 오브젝트파일을 모든,C파일로 만들어라
- gcc -g -c $(CCFLAGS) -I srcs/ -I libft/ $< -o $@옵션사용
- - srcs/ libft/하위의 헤더파일을 갖는, 최근갱신된 %.c파일을 -c옵션을 통해 컴파일하겠다.

#### Question
 - o옵션은 왜 사용하는지?

- -g gdb에게 제공하는 정보를 바이너리에 삽입한다.

                (-g 옵션을 사용하지 않고 gdb로 디버깅하면, 역어셈 → 어셈블리 코드로만 디버깅 가능)

- -c 오브젝트파일을 만듦, 컴파일 수행
- -I c소스 파일이 참조하는 헤더파일을 탐색할 디렉토리 지정 옵션. c소스가 갖는 헤더파일의 위치를 알려주는 옵션
- $< 더 최근에 갱신된 파일. 
- $@ TARGET파일

---

###### 9. 다음 학습 계획 (최소 5줄 이상)

- ft_printf 내용정리
- ~~백준 및 swea문제 풀기~~
- makefile 완성시키기
- ft_printf 설계 및 코드 참고
- 동료들과 코드비교 및 오류처리방법 토의
- 여러 테스트케이스를 만들어 생각하지 못한 예외처리를 할 것.