---
###### 1. 학습 날짜

- 2020-04-25(토)
 
---
###### 2. 학습시간

- 09:00 ~ 13:15(자가)
- 21:22 ~ 00:00(자가)

---
###### 3. 학습 범위 및 주제

- 스택 구현 큐 정리

---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스택 구현 및 큐 정리

---
###### 6. 상세 학습 내용

- 코드작성시간 : 5시간
- 
## 스택
#### 배열로 스택구현

- 스택 초기화할 때 seg fault발생
    - 스택구조체 동적할당 하지 않았음

- 스택 구조체 { int data[LEN], int top }
- isEmpty
- push
- pop
- peek
- print
- clear 구현

#### 백준

- 10828
    
- 스택 연산을 이용해 푸는 문제
    
- 10773
    
- 스택 연산을 이용해 푸는 문제
    
- 1874

  - 스택수열

  - 1 ~ n까지의 수열을 주어진 수열에 맞게 push, pop연산을 수행한다

  - push시 +, pop시 - 출력

  - 주어진 수열을 push, pop연산으로 수행할 수 없으면 NO 출력

  - ```
    // 인풋 데이터배열과 출력배열을 전역변수로 할당
    // 스택을 연결리스트로 구현
    // push, pop, init, clear, peek 구현
    
    // 더미노드 (데이터 : 0)를 생성하고, 그 이후에 1을 삽입한다
    // 만들어질 배열의 값과 현재 노드값을 비교하여 같으면, pop연산, 현재 노드가 배열보다 작으면, push연산을 수행하고, 출력배열에 각각 +, -를 쌓는다.
    // 현재 노드가 더미노드이면, push연산을 한번 더 수행한다. 만약 현재 노드가 만들어질 배열 값보다 크면 반복문을 종료한다
    // 만들어지는 배열의 인덱스와 초기 입력 값이 다르면 NO를 출력, 그렇지 않으면 출력배열을 출력한다.
    // 모든 로직이 종료되고 pop연산의 반복으로 스택을 비운다.
    ```

    - 오답
      - 3/ 1,3,2의 경우 NO가 출력됨 -> 첫번째 노드를 pop을 하고 , isEmpty이면 반복문을 종료시킨게 원인이었음. -> 더미노드를 추가하여 다음 노드를 한번 더 추가하도록 변경
      - 런타임에러 -> 메모리를 동적할당에서 전역변수 할당으로 변경함

## 큐

[https://velog.io/@pa324/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Queue%ED%81%90-udjxr0hb3x](https://velog.io/@pa324/자료구조-Queue큐-udjxr0hb3x)

### 개념

- 스택과 마찬가지로 일종의 리스트
- 삽입은 한쪽 끝에서, 삭제는 반대 끝에서
- 삽입이 일어나는 부분을 rear, 삭제쪽은 front라고 부른다.
- FIFO. 스택은 LIFO임.

### 연산

- insert, enqueue, offer, push : queue의 rear에 새로운 원소를 삽입하는 연산
  - enqueue : 큐 맨 뒤에 노드 추가.
  - rear : 큐 맨 뒤의 인덱스.
- remove, dequeue, poll, pop : queue의 front에 있는 원소를 queue로부터 삭제하고 반환하는 연산
  - dequeue : 큐 맨 앞쪽의 요소 삭제
  - front : 큐의 맨 앞의 인덱스
- peek, element, front : 큐의 front에 있는 원소를 제거하지 않고 반환하는 연산
  - peek : front에 위치한 데이터를 읽음
- is_empty : 큐가 비었는지 검사

### 응용

- cpu 스케쥴링: 프로세스들은 큐에서 CPU가 할당되기를 기다린다.
- 데이터 버퍼: 네트워크를 통해 전송된 패킷은 순서대로 버퍼에 저장됨
- 자원을 공유하는 대부분의 경우에 큐가 사용.

### 구현

### https://monsieursongsong.tistory.com/5

- 링크드리스트
  - 삭제- front, 삽입 rear이므로 , 연결리스트의 앞쪽을 front, 뒤쪽을 rear로 하는 것이 유리
  - 삽입을 하기 위해서 마지막 노드의 주소를 기억해야함.
- 배열
- 위의 두가지 모두 장, 단점을 가지므로 상황에 맞게 정하면 됨.
- 두가지의 문제점을 해결할 수 있는 원형-큐

---
###### 7. 학습 내용에 대한 개인적인 총평

- 1874번을 푸는데 오래걸렸다. 런타임에러와 오답케이스를 생각하지 못했기 때문에 해당 부분을 해결하는데 대부분 시간을 썼다.
- 알고리즘 문제를 풀 때 동적할당을 사용하는 것 보다 전역변수로 하라는 이유가 왜인지 알 것 같다. 해당 부분까지 신경쓰면 시간이 너무 오래걸리기 때문인 것 같다.
- 나머지 문제는 난이도가 그렇게 높지 않으니, 따로 풀은 로직만 정리하기로 했다.

---
###### 8. 다음 학습 계획
- 자료구조 학습(큐)
- 백준 알고리즘 문제
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리