

###### 1. 학습 날짜

- 2021 - 02 - 02(화)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- cpp05

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- Cpp05

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

- 평가표

  ex00

  - Bureacrat 클래스가 있고 name을 상수로 갖는가
    - 들어온 grade에 따라 예외처리 발생하고, 예외발생시 throw하여 예외를 처리하도록 함.
    - 예외처리는 catch에서 수행되고 what함수가 문자열을 리턴받아옴.
    - 이를 출력하는 것 std::cerr.
  - 1~ 150까지의 등급이 존재.
    - 생성자에서 해당 숫자 넘어서면 예외발생하도록 처리함
  - 예외처리가 잘되어있는지
  - getter속성이 있어야함
    - getName, grade등.
  - 증가, 감소함수가 있어야함.
    - up, downGrade있음
  - 예외를 명백히 던져야함.
  - 2는 1보다 낮은등급임.
  - << 오버로딩

  ex01

  - Form클래스. 이름과 bool을 가짐

  - 디폴트 false인 signed

  - 서명에 필요한 등급과 실행에 필요한 등급 존재

  - 이름과 등급은 상수

  - 모든 속성은 프라이빗이어야함. 프로텍티드 X

  - 1이 높은거, 150이 낮은거 예외처리 해야함

  - 속성에 대한 getter와 <<연산자 오버로딩 ⇒ Form에 대한 상태메시지 출력

  - Form::beSigned 멤버함수는 서브젝트에 명시된 대로 처리, Bureaucrat::signForm도 마찬가지임.

    - ```
      beSigned
      ```

       는 인자로 들어온 시장의 등급보다 form점수가 높아야함

      - 시장점수 3 > form점수 50 ⇒ OK
      - 50 > 3이면 fail⇒ TooLow에러
      - 충족하면 signed됨

    - `signForm` 은 해당 폼에 사인되었는지 확인하고, 싸인이 안되어있으면 싸인시킴. beSigned호출해서.

  ex02

  - Form클래스 잘 작성되었는지
  - Form::execute, Bureaucrat const &executor 서브젝트 명시처럼 잘작동하는지
  - Bureaucrat::executeForm이 서브젝 처럼 잘 동작하는지
    - 싸인이 안되어있거나, execGrade가 시장점수 > grade면 fail
    - form.execute실행 ⇒ 추상메소드 3개의 파생클래스에서 구현
      - 시장점수 > formExec점수 ⇒ fail
      - 아니면 OK ⇒ 각 Form마다 동작 수행
      - Presid...은 문구 출력
      - 로보토미는 1/2확률로 성공,실패문구출력
      - 슈베리는 들어간 name_shurb..로 만든 파일 생성

  ex03

  - makeForm이 포인터배열과 같이 작성되었는지, 각 Form의 생성자를 핸들링하고 있는지
  - 인턴클래스의 makeForm이 잘 동작하는지
    - 인턴이 이제 시장이하던일(execute)를 대신함. besigned도 함.
    - makeForm이라는 함수를 작성해야하는데 여기에 2개의 인자 생성
    - 하나는 수행할 form의 이름, 나머지는 form제목
    - form이름을 받아서 이에 해당하는 form생성자 수행함. 나머지 동일

반복, 예외처리

# 가상함수 훌륭한 설명 블로그

https://velog.io/@underlier12/C-07-다형성-dbk69cs1zz

# 예외처리 훌륭한 설명 블로그

https://egg-money.tistory.com/205

# 03까지

# ex00 커서 관료가 될래요;;

- 제출 ex00/Bureaucrat.hpp, cpp, main.cpp
- 모든 클래스에 대해 코프렌 폼 (캐노니컬)
- 뭐 되도않는 헛소리로 시작하고,,
- 1(가장 높은), 150(가장 낮은) 범위의 상수 이름과 등급이 있어야함.
- 유효하지 않은 등급으로 관료를 만들려는 모든 시도는 예외처리해야함.
- 이는 Bureaucrat::GradTooHighException or GradeTooLowException이 될 것임.
- `getName`, `getGrade` 만들고  등급을 낮추거나 높이는 기능을 가진 2개의 함수(upgrade, downgrade)를 작성
- 이 두 함수는 등급이 너무 높거나 낮은 경우 이전과 동일한 예외를 발생.
  - grade 1이 가장 높고, 150이 가장 낮기에 grade 3을 증가시키면 grade 2등급이 됨 ⇒ 뭐 점수처리를 역순으로 하라는 듯
- 예외는 다음과 같이 잡으셈

```jsx
try
{
/* do some stuff with bureaucrats */
}
catch (std::exception & e)
{
/* handle exception */
}
```

- <name>, bureaucrat grade <grade>로 출력하는 <<연산자 오버로드를 작성해.
  - ? 이게 다라고? 설명 좀 더해주라

Bureaucrat 클래스를 만드는데, 두가지 예외처리를 하는 함수를 만들고 이는 try catch로 처리한다.

getName, getGrade로 등급을 가져올 수 있고, upgrade를(뭐 이런걸로) 증가시키는데, 3→2→1 순으로 증가되게만들고, 1보다 내려가면 TooHigh로 예외처리, 150보다 커지면 TooLow예외처리 하라는듯.

# 예외 발생시키기 = throw

throw 로 예외로 전달하고 싶은 객체를 써주면 됩니다

이렇게 예외를 throw 하게 되면, throw 한 위치에서 즉시 함수가 종료되고, 예외 처리하는 부분까지 점프하게 됩니다. 따라서 throw 밑에 있는 모든 문장은 실행되지 않습니다.

```jsx
const T& at(size_t index) const {
  if (index >= size) {
    // 예외를 발생시킨다!
    throw std::out_of_range("vector 의 index 가 범위를 초과하였습니다.");
  }
  return data[index];
}
```

## try_catch

- try는 예외가 발생할만한 코드를 작성
- 예외 발생시 catch 호출하고, throw로 예외처리함.

# 예외 객체는 상속받는다.

일반적으로 예외 객체는 std::exception 을 상속 받는 것이 좋습니다. 왜냐하면 표준 라이브러리의 유용한 함수들(nested_exception 등) 을 사용할 수 있기 때문이지요.

예제

- `what()` 은 널로 끝나는 예외식별문자열을 반환함.
- what예제

[exception::what() in C++ with Examples - GeeksforGeeks](https://www.geeksforgeeks.org/exceptionwhat-in-c-with-examples/)

```jsx
//what 예제
#include<exception>

virtual const char* what() const throw();

// exception::what
#include <iostream>       // std::cout
#include <exception>      // std::exception

struct ooops : std::exception {
  const char* what() const noexcept {return "Ooops!\\n";}
};

int main () {
  try {
      throw ooops();
  } catch (std::exception& ex) {
      std::cout << ex.what();
  }
  return 0;
}

class FileNotFoundException : public exception { 
string message; public: 
// 1. 
FileNotFoundException(string _m): message("File not Found : " + _m){}
// 2.
virtual const char* what() const throw() {
 // 3.
 return message.c_str(); 
	} 
};

설명 

1. 생성자(constructor)

member variable 로 갖고 있는, message에 담아준다.

2. what() override 하기.

	1. virtual

		이 FileNotFoundException 클래스를 상속받는 다른 클래스가 있을 수 있기 때문에 써주었다.

	2. const

		what() 함수의 return type은 const char* 이다.

		즉, 문자열을 리턴 값으로 갖는다는 것인데,

		이 리턴 값은 변할 수 없으므로 const 를 적어 명시적으로 써준다.

	2.5 const throw()의미
		<https://stackoverflow.com/questions/5230463/what-does-this-function-declaration-mean-in-c>
		호출된 객체 상태를 변경하지 않고, 컴파일러에게 이 함수가 예외 발생을 허용하지 않을 것이라고 알려주는 것.
		예외를 던지지 않을 것이다.
	3. what()

		override를 수행할 함수의 이름이다.

	4. const

		외부 함수에서 만든 객체를 불러올 때, callbyreference 로 가져올 경우

		값을 변화 시킬 수 있다

출처: <https://egg-money.tistory.com/205> [완숙의 블로그]
```

# What 오버라이딩하기

http://www.cplusplus.com/forum/general/40011/

```jsx
class Exception_sam_base : public exception
{
public:

    Exception_sam_base();
    Exception_sam_base(string ErrorMsg);
    Exception_sam_base(const Exception_sam_base& orig);
    virtual ~Exception_sam_base() throw();
    static string ProgramName;
    void setErrorMessage(string str);
    void setErrorDetails(string str);
    void setErrorID(long int value);
    void setResolutionMessage(string str);
    vector< vector<string> >& VariableList();
    virtual const char* what();
private:
    string ErrorMessage;
...
}

const char* Exception_sam_base::what()
{
    return this->ErrorMessage.c_str();
}
```

# ex01

- 제출 /ex01 + Form.hpp, cpp
- Form grade가 20이면, beSigned(burea) ≤인자로 들어가는 bureaucrat의 grade는 20보다 작아야 sign이 true가 됨. 그리고 signForm를 호출해서 sign이 true, false에 따라서 문구가 달라지는 것 같음.
- private 지정자로 멤버변수 name, 그리고 사인 여부를 가리키는 boolean 을 가진다
  - 특정 grade에 만족해야 sign이 true가 됨.
- grade예외는 Form::gradeTooHigh/LowException 에서 처리한다.
- << 연산자 오버로딩 해야함

Form

- ```
  beSigned
  ```

   함수를 생성해야함

  - `Bureaucrat` 를 받는 함수임.
  - Bureaucrat의 grade가 Form의 기준 grade보다 크면(실제로 작으면) 현재 Form에 싸인함.
    - 반대의 경우에 예외발생. 시장 기준보다 Form 등급이 높으면
  - 관료가 가진 기준에 따라 Form에 싸인함.
    - 싸인이 되면 싸인되었다는 문구 출력
  - Form객체 <<로 출력했을 때 싸인여부와 기준 값들도 함꼐 출력함.
  - 

- `signForm` 함수를 `Bureaucrat`에 추가. 만약 서명이 성공하면 이 함수는 "<bureaucrat> signs <form>" 라고 출력함. 그렇지 않으면 "<bureaucrat> cannot sign <form> because <reason>". 를 출력하도록 함.

# ex02

- 이제 기본 양식이 있으므로 실제로 작업을 수행하는 몇 가지 양식을 만들 것입니다. 몇 가지 구체적인 양식을 작성하십시오.
- ShrubberyCreationForm (필수 등급 : 서명 145, exec 137). 작업 : <target> _shrubbery라는 파일을 만들고 그 안에 ASCII 트리를 현재 디렉터리에 작성하십시오.
- RobotomyRequestForm (필수 성적 : 서명 72, exec 45). 조치 : 드릴링 소리를 내고 <target>이 50 %의 시간 동안 성공적으로 로봇 화되었다고 알려주십시오. 그렇지 않으면 실패라고 알려주세요.
- PresidentialPardonForm (필수 성적 : 서명 25, exec 5). 조치 : <target>이 Zafod Beeblebrox에 의해 사면되었음을 알려줍니다.
- 이들 모두는 생성자에서 양식의 대상을 나타내는 하나의 매개 변수 만 가져와야합니다. 예를 들어 집에 관목을 심 으려면 "집"을 입력합니다. 양식의 속성은 기본 클래스에서 비공개로 유지되어야합니다.
- 이제 기본 폼에 execute (Bureaucrat const & executor) const 메서드를 추가하고 모든 구체적인 폼에서 폼의 액션을 실제로 실행하는 메서드를 구현해야합니다. 양식에 서명을했는지, 양식을 실행하려는 관료가 충분히 높은 등급인지 확인해야합니다. 그렇지 않으면 적절한  예외. 모든 구체적인 클래스에서 이러한 검사를 수행하든 7 C ++-모듈 05 반복 및 예외를 작성하든 기본 클래스를 확인한 다음 다른 메서드를 호출하여 실제로 작업을 실행하는 것은 사용자에게 달려 있지만 한 가지 방법이 다른 방법보다 분명히 더 예쁩니다. 어떤 경우 든 기본 양식은 추상 클래스 여야합니다.
- 관료에 executeForm (Form const & form) 함수를 추가하여 완료하십시오. 양식 실행을 시도해야하며 성공하면 <관료>가 <양식>을 실행하는 것과 같은 것을 인쇄합니다. 그렇지 않은 경우 명시적인 오류 메시지를 인쇄합니다.

슬슬 화나네... 문제를 똑바로 써줘야할거아냐 어떻게 문제 읽는데 수수께끼도 아니고 추론을 해야함? ;;

```
ShrubberyCreationForm
```

- 요구등급 : sign 145, exec 137
- 행동 : `<target>_shrubbery` 라고 불리는 파일을 생성하고 그 안에 ASCII코드(글자)로 만든 나무를 작성한다. 현재 디렉토리 내에 있어야함.

⇒ ;; 파일 생성함..

```
RobotomyRequestForm
```

- 요구등급 : sign 72, exec 45
- 행동 : 드릴 소리를 내고, 우리한테 `<target>` 이 시간의 50% 동안 성공적으로 로봇화되었다고 알려주래 그렇지 않으면 실패했다고 알려주래 , 뭐 생성자 호출하고 드릴소리 내면서 (시간은 어떻게 처리하는지 모르겠지만) 성공 또는 실패 메시지 알려주라는 것 같네

```
PresidentialPardonForm
```

- 요구등급 : sign 25, exec 5

- 행동 : `<target>` 가 Zafod Beeblebrox에 의해 용서,사면 되었습니다. 라는 걸 알려주래

  # Ex03

  - 양식을 작성하는 것은 충분히 성가시기 때문에 관료들에게 직접 작성하도록 요청하는 것은 잔인 할 것입니다. 아니, 그냥 인턴이하도록하겠습니다.
  - 인턴 클래스를 만들 것입니다. 인턴은 이름도, 등급도, 특징도없고, 그 일을하는 데에만 신경을 씁니다.
  - 인턴에게 중요한 것은 makeForm 함수입니다. 첫 번째는 양식의 이름을 나타내고 두 번째는 양식의 대상이되는 두 개의 문자열을 사용합니다. 그것 두 번째 매개 변수로 초기화 된 첫 번째 매개 변수가 나타내는 구체적인 양식 클래스에 대한 포인터를 Form에 대한 포인터로 리턴합니다. "Intern create <form>"과 같은 것을 표준 출력에 인쇄합니다.
  - 더 나쁜 방법을 사용하는 경우 if / elseif / elseif / else 분기 또는 이와 같은 다른 추악한 것들은 평가 중에 허용되지 않습니다. 요청 된 양식을 알 수없는 경우 명시적인 오류 메시지를 인쇄하십시오.
  - 예를 들어 다음은 "Bender"를 대상으로하는 RobotomyRequestForm을 생성합니다.

  # makeForm

  - name, target을 인자로 받는다.
    - name은 어떤 Form을 만들지에 대한 Form형식
    - target는 그 객체가 가진 이름을 뜻함.
  - 

  ```jsx
  Form * (Intern:: *forms[3])(std::string const) = {
  		&Intern::makeRobotomyRequestForm,
  		&Intern::makePresidentialPardonForm,
  		&Intern::makeShrubberyCreationForm
  	};
  ```

---

###### 7. 학습 내용에 대한 개인적인 총평

- 예외처리에 대한 내용을 학습했다.

###### 8. 다음 학습 계획

- cpp06