---
###### 1. 학습 날짜

- 2020-05 -16(토)
 
---
###### 2. 학습시간

- 13:00 ~ 16:00 (자가)

---
###### 3. 학습 범위 및 주제

- 스프링
---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스프링

---
###### 6. 상세 학습 내용

- 코드작성시간 : 3 시간




### create(insert) 처리

현재 예제는 bno을 PK로 이용하고, 시퀀스를 통해 자동으로 번호가 생성된다. 이럴 때 2가지 방식으로 처리할 수 있다.

1. insert만 처리되고 생성된 PK(bno)를 알 필요 없는경우
2. insert문이 실행되고 PK를 알아야 하는 경우

이를 고려해서 작성한다. (BoardMapper.java)인터페이스

```java
	public void insert(BoardVO board);
	public void insertSelectKey(BoardVO board);
		
```



BoardMapper.xml

```xml
	
	<insert id="insert">
		insert into tbl_board (bno, title, content, writer)
		values (seq_board.nextval, #{title}, #{content}, #{writer})
	</insert>
	

	
	<insert id="insertSelectKey">
		<selectKey keyProperty="bno" order="BEFORE" resultType="long">
			select seq_board.nextval from dual			
		</selectKey>
	
		insert into tbl_board(bno, title, content, writer)
		values(seq_board.nextval, #{title},#{content} ,#{writer})
	</insert>
	
	</mapper
```

insert는 bno의 값을 삽입할 때 nextval을 이용하므로, 값을 알 수 없지만 

SelectKet는 nextval에서 받아온 시퀀스 값을 bno에 저장하기 때문에 출력할 수 있다. 이때 출력되는 값은 시퀀스값(중복X)은 환경마다 다를 수 있다.



#### 테스트 코드

```java
	@Test
	public void testInsert() {
		
		BoardVO board = new BoardVO();
		board.setTitle("새로 작성하는 글");
		board.setContent("새로 작성 내용");
		board.setWriter("newbie");
		
		mapper.insert(board);
		
		log.info(board); // bno가 null로 출력된다.
	}
	
	@Test
	public void testInsertSelectKey() {
		
		BoardVO board = new BoardVO();
		board.setTitle("새로 작성하는 글");
		board.setContent("새로 작성 내용");
		board.setWriter("newbie");
		
		mapper.insertSelectKey(board);
		
		log.info(board); // bno=25가 결과로 나온다. 이는 시퀀스 값으로 환경마다 다른 값이 나옴(중복 없는 값을 위함)
	}
}

```

---



### read(select)처리

인터페이스를 작성한다.

```java
public BoardVO read(long bno);
```



mapper.xml을 작성한다

```xml
<select id="read" resultType="org.zerock.domain.BoardVO">
	select * from tbl_board where bno = #{bno}
	</select>
```



테스트코드를 작성한다.

```java
@Test
public void readTest(){
	BoardVO board = mapper.read(5L);
	log.info(board);
}
```

5번 게시물이 출력되는 것을 볼 수 있다.



### Delete처리

인터페이스를 작성한다.

```java
public int delete(long bno);
```



XML을 작성한다.

```xml
<delete id="delete">
	delete from tbl_board where bno = #{bno}
</delete>
```



테스트코드를 작성한다.

```java
@Test
public void testDelete(){
	log.info("DELETE COUNT: "+ mapper.delete(3L));
}
```

정상적으로 삭제되었으면 다음과 같은 출력문이 나온다.

INFO : org.zerock.persistence.BoardMapperTests - DELETE COUNT: 1

카운트는 몇개의 데이터가 삭제되었는지를 알려준다.



### Update 처리

제목, 내용, 작성자를 수정한다. delete와 마찬가지로,  몇개의 데이터가 수정되었는지 처리할 수 있으므로 int형으로 작성한다.



인터페이스를 작성한다.

```java
public int update(BoardVO board);
```

xml을 작성한다.

```xml
<update id="update">
	update tbl_board
		set title = #{title},
		content = #{content},
		writer = #{writer},
		updatedate = sysdate
		where bno = #{bno}
</update>
```



테스트코드를 작성한다.

```java
@Test
public void testUpdate(){
			BoardVO board = new BoardVO();
		board.setBno(1L);
		board.setTitle("수정된 제목");
		board.setContent("수정된 내용");
		board.setWriter("user01");
		
		int count = mapper.update(board);
		log.info("UPDATE COUNT: " + count);	
}
```



수정이 완료되었으면, COUNT가 갯수에 맞춰 출력된다.



---
###### 7. 학습 내용에 대한 개인적인 총평
- 영속계층의 CRUD를 구현했다. 영속계층은 DB를 기준으로 구현하고, 비즈니스는 로직을 기준으로 구현한다.
오늘 구현한 내용은 영속계층이다. Mapper인터페이스에서 select, update, delete, insert로 데이터를 주로 다루었다.
다음에 학습할 비즈니스계층에서는 Service의 로직을 다룬다. 고객의 정보를 등록하고 리스트를 출력하며 삭제 및 데이터 수정을 로직으로 진행한다.
테스트코드에 작성한 내용과 비슷하지만 프로젝트안에서 수행하는 점이 다르다. 다음 예제만 마무리한 후 책없이 혼자서 영속계층, 비즈니스계층 CRUD를 구현할 계획이다.
###### 8. 다음 학습 계획
- 백준 문제풀이
- 웹 프로그래밍 학습
- 스프링 학습
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리