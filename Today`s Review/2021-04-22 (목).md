###### 1. 학습 날짜

- 2021-04-22 (목)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 불변성

---

###### 4. 동료 학습 방법 

- sooyoon, chlim

---

###### 5. 학습 목표 

- 불변성을 지켜야하는 이유

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

### **불변성이란?**

기존의 값을 그대로 유지하면서 새로운 값을 추가하는 것으로 객체생성 이후 그 상태를 변경할 수 없는 디자인 패턴.

원시타입은 함수의 인자로 넣었을 때 메모리에 새로 할당해 이를 전달하는 `call by value`이지만, 객체나 배열의 경우 레퍼런스를 전달하는 `call by reference` 방식이 사용된다.

어떤 함수가 객체의 프로퍼티의 값을 변경했다고 해보자.

나중에 사이즈가 커졌을 때 어디서 어떤 함수로 인해 이 프로퍼티값이 변경되었는지 디버깅하기 어렵다. 또 리액트에서는 상태변화를 통해 리랜더링하는 과정을 사용하는데, 프로퍼티값이 변경되었음에도 불구하고 동일한 레퍼런스이기 때문에 값이 변경되도 리랜더링되지 않는다.

간략하게 줄이면, 디버깅하기 어렵고, 상태변화를 추적할 수 없다.

언제? 배열이나 객체처럼 `call by reference` 에서 값을 변경했을 때.

왜? 같은 레퍼런스이므로 값이 변경되어도 변화를 감지할 수 없어서.

리액트에서 불변성을 지킨다는 것은 값이 변경되었을 때, 원본 상태를 훼손시키지 않고, 배열, 객체의 레퍼런스를 새로 반환하는 것과 같다고 생각한다.

그러나 흔히 사용하는 `spread, object.assgin`은 얕은 복사를 통해 1depth만큼의 복사만 되고 프로퍼티내 객체가 존재하면 이를 같은 레퍼런스로 보기에 2depth 비교는 할 수 없다.

불변을 지키면서 2depth구조의 객체 상태를 변화시키기 위해서는

```
let state = {
  ...state,
  name:{...name}
}
```

위와 같은 방식으로 중첩해서 사용해야한다.

이와 같이 얕은 비교를 spread연산자로 할 수 있다.

만약 10depth면 저 과정을 9번 더 해야한다. (끔찍스)

그래서 `Immer`와 같은 불변성 유지를 편하게 해주는 라이브러리를 사용한다.

[참고](https://evan-moon.github.io/2020/01/05/what-is-immutable/)

---

###### 7. 학습 내용에 대한 개인적인 총평

- 불변성을 꼭 지켜야 리액트가 상태관리를 할 수 있고 그에 대한 랜더링도 수행한다.

###### 8. 다음 학습 계획

- 면접