---
###### 1. 학습 날짜

- 2020-05 - 24(일)
 
---
###### 2. 학습시간

- 17:00 ~ 24:00 (자가)

---
###### 3. 학습 범위 및 주제

- 스프링
---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스프링

---
###### 6. 상세 학습 내용

- 코드작성시간 : 7 시간

## 스프링 #15 오라클 DB 페이징 처리



SQL에서 정렬하기 위해선 'order by'를 이용한다. 하지만 데이터가 많은 경우에서 성능 저하를 가져오기때문에 주의해야한다.

---

#### 실행계획, order by



페이징을 위해 반드시 알아야 할 것 = 실행계획



실행 계획 : SQL을 DB에서 어떻게 처리할 것인가? 라는 계획을 두는 것이다.



DB에 전달된 SQL문은 파싱, 최적화, 실행과정을 거친다.

- 파싱단계: SQL구문 오류파악, SQL 실행 대상객체 존재 검사
- 최적화단계: SQL실행에 필요한 비용(cost)계산 해당 비용으로 어느 방식으로 실행할지 실행 계획을 세운다.
- 실행단계: 세워진 실행 계획으로 작업을 진행한다.

SQL PLUS 등을 이용해 특정 SQL에 대한 실행 계획을 알 수 있다.



![실행 계획](https://user-images.githubusercontent.com/55486644/82750701-d2a39500-9dec-11ea-8581-aa2d0d3c6106.JPG)

sql developer에서 확인한 실행 계획



SQL 튜닝은 이를 확인하고 더 좋은 방식으로 수정하는 것.



#### order by보다 인덱스

인덱스는 정렬되어 있다. = 정렬과정이 필요 없다.

DB에서 PK는 식별자라는 의미도 있지만, 인덱스의 의미를 가진다. 인덱스라는 객체를 만들기 위해 PK를 지정한다.

데이터가 많아지면 정렬작업으로 인해서 시간이 걸린다는 점이 있는데, 이를 해결하기 위한 가장 일반적인 방법은 인덱스를 이용해 정렬을 생략하는 방법이다.



위의 사진의 SQL실행계획에서 주의해서 봐야할 부분은 정렬작업을 했는지, 기본 테이블에 바로 접근하지 않고 PK_BOARD에 접근했는지, BY INDEX ROWID, FULL SCAN인지 보는 것이다.



해당 테이블에서 bno(PK)라는 기준으로 인덱스를 생성한다. 인덱스는 ROWID라는 값을 갖게되는데, 이 값은 DB내의 주소이다.



모든 데이터는 자신만의 주소를 갖고있다. 즉, PK라고 지정된 bno는 순서대로 정렬된 ROWID를 가지고 있다. 인덱스에서 가장 중요한 개념이다. 바로 정렬 되어 있다는 점이다.



---

#### 인덱스와 오라클 힌트(hint)



웹 페이지의 목록은 주로 시간 역순으로 정렬결과를 보여준다.



말 그대로 최신 데이터를 가장 먼저 보여주는 것이다.



예를들어,

이 경우에 개발자는 정렬 안하는 방식으로 select 문을 실행하고 싶다고 한다.

이때 select를 전달할 때 힌트를 사용할 수 있다.

힌트란 DB에 ""내가 전달한 select문을 이렇게 실행해라''라는 것이다. 

힌트는 에러가 나도 SQL에 지장을 주지 않으므로 "확인하는 습관"이 중요하다.



다음 SQL문을 살펴보자

```
select * from tbl_board order by bno desc;

selct /*+INDEX_DESC (tbl_board pk_board)*/ * from tbl_board;
```

두 구문은 같은 결과(데이터 역순 정렬)를 생성한다.



두번째에서 order by 없이 동일 결과나오는 것에 주목한다. 

tbl_board테이블에, pk_board인덱스를 역순으로 이용해 줄 것이라는 힌트이다.



---



#### 힌트 사용 문법

```
SELECT /*+ Hint name(param) */ column name,....
FROM table_name
```

 힌트는 /*로 시작, */으로 마무리 된다. 칼럼명이 나와도 ,으로 처리하지 않는다.

---



####  FULL 힌트



select문 실행시 테이블 전체 스캔을 명시하는 것

```
select /*+ FULL(tbl_board) */ * from tbl_board order by bno desc;
```





#### INDEX_ASC, INDEX_DESC힌트



목록 페이지에서 가장 많이 사용하는 힌트

인덱스를 순서, 역순으로 이용할지 지정하는 것

```
select /*+ INDEX_ASC(tbl_board pk_board)*/ * from tbl_board where bno > 0;
```





#### ROWNUM과 인라인뷰



지금까지 전체 데이터를 역순으로 처리하는 방법(order by, 인덱스, 힌트를 통한 정렬)을 진행했다.



페이징 처리를 위해, 필요한 만큼의 데이터를 가져오는 방식을 보겠다.



ROWNUM을 이용해 데이터에 순번을 붙여 사용하는 방법을 알아보자.

SQL 실행 결과에 넘버링을 해준다고 생각하면 된다.

SELECT문에는 ROWNUM이라는 변수로 해당 데이터가 몇 번째로 나오는지 알 수 있다. (실제 데이터가 아닌, 데이터 추출 후 처리되는 변수, 상황에 따라 달라진다.)



![rownum](https://user-images.githubusercontent.com/55486644/82751240-ddf8bf80-9df0-11ea-85f1-00c7232499c6.JPG)

**rownum이 출력된 결과**

BNO41번이 RN에서는 1번을 갖는다. 그러나, 

![rownum 달라지는 번호](https://user-images.githubusercontent.com/55486644/82751349-7e4ee400-9df1-11ea-87a1-8e7c53132592.JPG)

오름차 정렬을 한 순간 4번이 RN1번을 갖게 된다. 따라서

데이터 처리에 따라 달라지는 번호라고 생각하면 될 것 같다. 



이를 이용해 페이징처리를 한다고 생각하면, 목록페이지에서 역순으로 가장 최근 데이터를 보여주어야 하니까, 내림차순으로 정렬(인덱스를 이용 또는 order by 이용)한다면 가장 최근 데이터부터 RN이 1부터 부여될 것이므로, 10개씩 페이지를 보여주고싶으면 1부터 10까지 1페이지에 해당하게 작성하면 된다.



#### 페이지 번호 1,2의 데이터



페이지당 10개의 데이터를 출력한다면 ROWNUM 조건을 WHHERE구문에 추가해서 작성하면 된다.

```
select /*+INDEX_DESC(tbl_board pk_board) */
	rownum rn, bn, title, content
from tbl_board
where rownum <= 10;
```

- 1~10까지 역순으로 된 데이터 출력



그렇다면 10~20은 어떻게 가져올까?

where절을 rownum > 10 and rownum <= 20;으로 지정한다면? => 아무일도 일어나지 않는다! 이때 실행계획을 살펴본다.

먼저 실행 계획은 ROWBUM>10부터 찾는다.

그러나 ROWNUM값의 시작은 1이기 때문에 찾을 수 없는 것이다.

그러므로 rownum을 가져올 때 사이 값을 가져오면 안되고 1을 포함한 시작값부터 해당 지점까지 모두 불러와야한다.

where rownum <= 20;



#### 인라인 뷰 

이제 1~10데이터를 처리하기 위해 인라인뷰를 이용한다.

인라인뷰는 "select문 안쪽 from에 다시 select문"이라는 의미이다.

다시말해 어느 결과를 select로 구하고, 그 결과를 다시 select하는 것

SQL구문을 보면 바로 이해할 수 있다



```
select bno, title, content
from (select /*+INDEX_DESC(tbl_board pk_board) 			rownum rn, bno, title, content
	 from tbl_board
	 where rownum <= 20)
where rn > 10;
```



from안쪽에서 rownum을 사용한 것, 바깥에서 rn을 사용한 것?

안쪽에서 rn이라고 불리는 rownum을 가져오기 위해 rownum을 사용-> 결과물이 rn으로 불리는 데이터로 출력

바깥에서 rn이라는 데이터를 이용하기 때문에 rn사용



## 스프링 #16 MyBatis, 스프링에서의 페이징 처리



페이징 처리를 위해 필요한 파라미터가 있다.

1. 페이지번호(pageNum)
2. 한 페이지당 몇개의 데이터를 보여줄 것인지.(amount)

예제를 통해 구현해보도록 한다.



domain에 Criteria클래스를 생성하고 작성한다.

```java
@Data
public class Criteria {
	
	private int pageNum;
	private int amount;
	
	public Criteria() {
		this(1, 10);
	}

	public Criteria(int pageNum, int amount) {
		this.pageNum = pageNum;
		this.amount = amount;
	}
}

```



#### MyBatis 처리 및 테스트



mapper패키지의 BoardMapper에 Criteria타입을 파라미터로 사용하는 getListWithPaging()메소드를 작성한다.

그리고 xml에 10~20rn의 값을 갖는 데이터를 가져오도록 작성하고 테스트도 해보자.



```xml
<select id="getListWithPaging" resultType="org.my.domain.BoardVO">
		<![CDATA[
			select bno, title, content, writer, regdate, updatedate
			from (select /*+INDEX_DESC(tbl_board pk_board)*/ rownum rn, bno, title, content, writer, regdate, updatedate
					from tbl_board
					where rownum <= 20)
			where rn > 10
		]]>
</select>
```

![페이징 데이터 출력](https://user-images.githubusercontent.com/55486644/82751969-f61f0d80-9df5-11ea-81b9-200827a4823c.JPG)



10, 20이라는 데이터를 사용하긴 했지만 결국 이 둘은 위에서 언급한 pageNum, amount에의해 조절되는 값이다.

20은 pageNum * amount

10은 (pageNum - 1) * amount. 이제 xml을 해당하는 값에 맞춰 변경해보도록 한다.

```xml
where rownum <= #{pageNum} * #{amount})
		where rn > (#{pageNum} - 1) * #{amount}
```

테스트 코드시 정상동작을 확인할 수 있다.





### BoardController, BoardService 수정

목록을 출력하는 부분을 수정한다.

이에 해당하는 부분은 getList메소드이다. 이는 Controller, Serivce에서 사용하므로 변경하도록 한다.



**BoardController 테스트**

Controller테스트를 위해선 mockito프레임워크를 사용해야한다.

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-all</artifactId>
    <version>1.9.5</version>
    <scope>test</scope>
</dependency
```



MockMvc를 사용하고, root-context에 controller를 스캔할 수 있도록 Component scan을 추가한다.

어노테이션설정은 기본과 동일한데 @Before로 선언된 setUp메소드를 먼저 수행하고 나머지 테스트를 수행한다.



```java
@Setter(onMethod_ = { @Autowired })
	private WebApplicationContext ctx;

	private MockMvc mockMvc;

	@Before
	public void setup() {
		this.mockMvc = MockMvcBuilders.webAppContextSetup(ctx).build();
	}

	@Test
	public void testListPaging() throws Exception{
		
		log.info(mockMvc.perform(
				MockMvcRequestBuilders.get("/board/list")
				.param("pageNum", "2")
				.param("amount", "10"))
				.andReturn().getModelAndView().getModelMap());
	}
	
```





![1~10 데이터를 불러온 페이징 준비화면](https://user-images.githubusercontent.com/55486644/82752958-c8899280-9dfc-11ea-9990-1bce9d19a93c.JPG)



1~10까지 데이터를 불러온 화면


## 스프링 #17 페이징 화면처리



```
http://localhost:8090/board/list?pageNum=3
```

이전까지의 내용은 해당 값으로 브라우저에 요청을 하면 페이징을 나누어 이동할 수 있었다.



이번에는 밑에 페이지번호를 추가하여 클릭시 해당 페이지로 이동할 수 있도록 하는 것을 구현하고자 한다.

다음 과정을 통해 진행한다.

1. 브라우저 주소창에서 페이지 번호를 전달해 결과를 확인
2. JSP에서 페이지 번호를 출력
3. 각 페이지 번호에 클릭 이벤트 처리
4. 전체 데이터 갯수를 반영해 페이지 번호 조절



페이징은 단순 링크연결이지만, 조회, 수정, 삭제페이지까지 페이지 번호가 계속 유지되어야 하기 때문에 이를 신경써야 한다. 





#### 페이징을 위한 필요한 정보

- 현재 페이지 번호
- 이전, 다음으로 이동 가능한 링크 표시여부(prev, next)
- 화면에서 보여지는 페이지 시작, 끝 번호(startPage, endPage)



----



#### 끝, 시작 페이지 번호



시작보다 끝 페이지 번호를 먼저 구하는 것이 수월하다.

```java
this.endPage = (int)(Math.ceil(페이지번호 / 10.0)) * 10;
```

10페이지씩 나눈다고 가정한 코드

ceil은 소수점 올림으로 처리한다. 

ceil(0.1) = 1 

ceil(1) = 1

ceil(1.1) = 2

그러므로 페이지번호가 1~10까진 마지막페이지가 10페이지, 11~20까진 20페이지로 계산할 수 있다.



그러나 페이지수가 10개가 되지 않으면 끝 번호가 10으로 끝나면 되면 안된다. 그럼에도 끝을 먼저 구하는 이유는 시작페이지번호 계산이 수월해지기 때문이다.



```java
this.startPage = this.endPage - 9;
```



- 시작번호는 1, 11, 21.. 이렇게 지정됨



그렇다면 시작번호를 수월하게 구했으니, **전체 데이터 수(total)**를 이용해 진짜 마지막 페이지를 구해본다.

total이 80이었을 떄 마지막 번호는 10이아닌 8이되어야한다.

if 이렇게 해서 구한 값이 원래 endPage(10)보다 작으면 endPage값을 8로 변경한다.

```java
realEnd = (int)(Math.ceil(total * 1.0)) / amount));//total이 8일 때 8페이지, 81이면, 9페이지가 됨

if(realEnd < this.endPage)//realEnd가 10보다 작다면, endPage는 작은 값으로 변경
	this.endPage = realend;
```

---





#### 이전, 다음



이전 값은 시작 번호가 1보다 큰 경우일 때 존재한다.

2페이지일 때 1페이지로 넘어가기 위해서.

```java
this.prev = this.startPage > 1;
```



다음 값은 realEnd가 끝 번호보다 큰 경우에만 존재한다.

현재 2페이지이면, endPage는 10일 때, realEnd가 8페이지 밖에 없다면 다음으로 넘어가는 값은 존재하지 않는다.

realEnd가 22페이지라면 다음으로 넘어가는 값이 필요하다.

```java
this.next = this.endPage < realEnd;
```





---



### 페이징 처리를 위한 클래스 설계



domain에 PageDTO클래스를 작성한다.

```java
@Data
public class PageDTO {

	private int startPage;
	private int endPage;
	private boolean prev, next;
	
	private int total;
	private Criteria cri;
	
	public PageDTO(Criteria cri, int total) {
		this.cri = cri;
		this.total = total;
		
		this.endPage = (int)(Math.ceil(cri.getPageNum() / 10.0)) * 10;
		this.startPage = this.endPage - 9;
		
		int realEnd = (int)((Math.ceil(total / 1.0) / cri.getAmount()));
		
		if(realEnd < endPage)
			this.endPage = realEnd;
		
		this.prev = this.startPage > 1;
		this.next = this.endPage < realEnd;
		
	}
}
```



여기서 계산된 값들을 Controller에서 View로 전달하기 위해 model에 담아야한다. list메소드를 수정한다.

```java
	@GetMapping("/list")
	public void list(Criteria cri, Model model)
	{
		log.info("list: "+ cri);
		model.addAttribute("pageMaker", new PageDTO(cri, 123));
		model.addAttribute("list", service.getList(cri));
	}
	
```

- 생성자에서 전체 데이터(total)을 가져와야 하는 부분을 추가해야한다.



---



### JSP에서 페이지 번호 출력



테이블 하위단에 해당 JSP를 작성한다.



```java
		<div class="pull-right">
			<ul class="pagination">
				<c:if test="${pageMaker.prev }">
					<li class="paginate_button previous" ><a href="#">Previous</a>
				</c:if>
				
				<c:forEach var="num" begin="${pageMaker.startPage }"
					end="${pageMaker.endPage }">
					<li class ="paginate_button"><a href="#">${num }</a></li>
				</c:forEach>
				
				<c:if test="${pageMaker.next }">
					<li class="paginate_button next"><a href="#">Next</a></li>
				</c:if>
			</ul>
		</div>
```

---





#### 페이지 번호 이벤트처리



```jsp
	<li class ="paginate_button" ${pageMaker.cri.pageNum == num ? "active":"" }"><a href="${num }">${num }</a></li>
```



```jsp
<li class="paginate_button next"><a href="${pageMaker.endPage + 1 }">Next</a></li>
```



![a태그 페이짇ㅇ](https://user-images.githubusercontent.com/55486644/82755203-20c89080-9e0d-11ea-86aa-b8d8af1f299f.JPG)

a태그의 href속성값으로 번호만을 가지게 변경된다.

해당 버튼을 클릭시 /board/번호로 이동되는 것을 확인할 수 있다.

```jsp
<form id='actionForm' action="/board/list" method='get'>
		<input type='hidden' name='pageNum' value = '${pageMaker.cri.pageNum}'>
		<input type='hidden' name='amount' value = '${pageMaker.cri.amount }'>
</form>

<script type="text/javascript">
	$(document).ready(function(){
		var actionForm = $("#actionForm");
		
		$(".paginate_button a").on("click", function(e){
			e.preventDefault();
			console.log('click');
			
			actionForm.find("input[name='pageNum']").val($(this).attr("href"));
			actionForm.submit();
		});
	});
</script>
```



pageNum, amount를 가진 form태그를 만든 후 페이지 버튼을 클릭했을때 이벤트를 처리하도록 스크립트를 작성한다.



해당 값을 가진 객체(actionForm)은 페이지 버튼(paginate_button)이 클릭되었을때,  paginate_button의 a태그 href속성값을 actionForm의 pageNum에 넣고 get방식으로 /board/list에 제출한다.



controller의 GetMapping어노테이션을 가진 getList메소드는  해당하는 값을 cri객체에 매핑하고 이를 통해 목록을 출력하게 된다.



게시글을 눌렀을때 list버튼을 누르게 되면, 첫 페이지의 목록이 출력되는데 이는 default로 설정된 값이 cri에 있기 때문에 pageNum, amount를 get페이지에서 list로 넘겨주어야한다.



그렇다면 list페이지에서 게시글을 눌렀을때 현재의 pageNum과 amount를 넘겨주는 것 부터 진행해야한다.



```jsp
	<td>
						<a class='move' href='<c:out value="${board.bno }"/>'>
						<c:out value="${board.title }"/>
						</a>
					</td>
```

기존에는 제목에 href링크를 걸어 bno값만 전달했지만 a태그로 클래스를 묶어서 스크립트에서 나머지 값까지 함께 전달할 것이다.



```jsp
		$(".move").on("click", function(e){
			e.preventDefault();
			actionForm.append("<input type='hidden' name='bno' value='"+$(this).attr("href")+"'>");
			actionForm.attr("action", "/board/get");
			actionForm.submit();
		});
```

move버튼이 클릭되었을때, actionForm(pageNum, amount가 담겨있는 form태그)에다가 move라는 이름의 a태그안의 href속성값(c:out)을 가진 input 태그를 덧 붙인다.

actionForm의 속성값 action을 /board/get으로 지정한다.

actionForm을 해당 URL에 제출한다.



그렇다면 제목을 클릭했을때 move on Click이 실행되고, actionForm태그에 있는 내용 + bno값이 추가되어 controller의 get 메소드를 호출하게 된다.



```java
	@GetMapping({"/get", "/modify"})
	public void get(@RequestParam("bno") int bno, @ModelAttribute("cri") Criteria cri, Model model) {
		log.info("get..modify.......: page : "+cri.getPageNum() +"amount"+ cri.getAmount());
		
		model.addAttribute("board", service.get(bno));
	}
```

컨트롤러의 get메소드는 ModelAttribute로 View에서 전달한 값을 Criteria에 매핑시킨다.

cri.get메소드를 수행하면 list페이지에서 전달한 값이 들어오는 것을 확인할 수 있다.



![2페이지 목록](https://user-images.githubusercontent.com/55486644/82757101-317f0380-9e19-11ea-8e76-edf5f533b8a6.JPG)
![2페이지 게시글 클릭](https://user-images.githubusercontent.com/55486644/82757105-32179a00-9e19-11ea-8941-06f0105e0b43.JPG)





이제 앞서말한 조회페이지에서 list를 눌렀을 때 디폴트 페이지로 넘어가는 이슈를 해결해야한다.



마찬가지로 get페이지에서 pageNum, amount값을 넘겨준다.

get페이지에서는 operForm의 폼태그에 데이터를 담는다.



```jsp
			<form id='operForm' action="/board/modify" method="get">
				<input type='hidden' id='bno' name='bno' value='<c:out value="${board.bno }"/>'>
				<input type='hidden' id='pageNum' name='pageNum' value='<c:out value="${cri.pageNum }"/>'>
				<input type='hidden' id='amount' name='amount' value='<c:out value="${cri.amount}"/>'>
			</form>
```



그리고 동작확인시 해당 게시글이 속한 페이지로 돌아가는 것을 확인할 수 있다.

---

###### 7. 학습 내용에 대한 개인적인 총평

- 페이징처리에 대한 학습을 진행했다. 학습을 할 수록 jquery와 스크립트에 대한 기본이 없어 이해하는데 오래 걸릴 때가 있다.
- 아직까지는 그렇게 큰 무리는 없지만 더 깊게 이해하기 위해서 반드시 해야할 것 같다.
- jquery대신 순수 자바스크립트를 사용하라는 말을 봤는데 뭐가 더 좋은지, 기업에서 무엇을 더 선호하는지 몰라 학습 계획을 세우는데 애로사항이 있다.
- 25일에는 구현한 것을 다시 예제코드에다가 적용할 계획이다.
- 그리고 세부계획이 없다보니 다른 학습을 진행하지 못하고 있다. 좀 고민을 해서 계획을 세워야겠다.

###### 8. 다음 학습 계획
- 백준 문제풀이
- 웹 프로그래밍 학습(자바스크립트, CSS레이아웃배치)
- 스프링 학습
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리