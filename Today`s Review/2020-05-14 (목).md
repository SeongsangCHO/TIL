---
###### 1. 학습 날짜

- 2020-05 -14(목)
 
---
###### 2. 학습시간

- 08:00 ~ 21:52(자가)

---
###### 3. 학습 범위 및 주제

- 스프링
---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스프링

---
###### 6. 상세 학습 내용

- 코드작성시간 : 6 시간
## 스프링 #07 스프링 MVC Controller

스프링 MVC를 이용하는 경우 Controller의 특징

- HttpServletRequest, HttpServeletResponse를 거의 사용할 필요 없이 필요기능 구현
- 다양한 타입 파라미터, 리턴 타입 사용 및 처리
- GET, POST방식 등 처리를 어노테이션으로 가능
- 상속, 인터페이스 방식 대신 어노테이션 만으로 필요한 설정 가능

=> 각 어노테이션의 의미에 대해 주의하며 학습 @



### @Controller, @RequestMapping

- SampleController을 작성해보자

```java
@Controller
@RequestMapping("/sample")
public class SampleController {

}

```

작성된 해당 클래스는 자동으로 스프링의 Bean으로 등록이 된다. 무엇때문에?



바로 servlet-context.xml의 태그 때문에 등록이 되는 것.

```xml
<context:component-scan base-package="org.zerock.controller" />
```

해당 파일에서는 **component-scan**태그를 통해 해당 package내의 클래스들을 조사하면서, Bean설정에 사용되는 **어노테이션**들을 가진 클래스들을 파악하고, 필요시 객체로 생성 및 관리하기 때문이다.

![스프링관리파일](https://user-images.githubusercontent.com/55486644/81806673-c64f4a80-9557-11ea-892e-24157d16cc39.JPG)

스프링이 관리해주는 파일은 옆에 S라고 추가된다.





@RequestMapping

- 현재 클래스내의 모든 메소드들의 기본 URL경로가 된다.
- 클래스선언뿐만아니라 메소드선언에도 사용 가능하다.

- method 속성(GET, POST방식으로 구분할 때 사용)
- @GetMapping @PostMapping







## Controller의 파라미터 수집

클라이언트의 요청에 필요한 데이터를 추출하고, VO 또는 DTO로 변환하는 파라미터 수집 작업! 스프링 MVC는 이를 자동으로 처리해줌 ! => RequestParam 어노테이션으로!

매번 request.getParameter()을 사용하지 않아도 됨.



- org.zerock.domain ( SampleDTO.java )생성

```java
@Data
public class SampleDTO {
	private String name;
	private int age;
}

```



- HomeController

```java
@Log4j
@RequestMapping("/sample/*")
@Controller
public class HomeController {
	
	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);
	
	
	@GetMapping("/ex01")
	public String ex01(SampleDTO dto) {
        dto.setAge(10);
		dto.setName("seongsang");
		log.info("" + dto);
		return "ex01";
	}
```

INFO : org.zerock.controller.HomeController - SampleDTO(name=seongsang, age=10)



배열, 배열리스트, 객체리스트 처리

```java
//배열
@GetMapping("/ex02Array")
	public String ex02Array(@RequestParam("ids") String[] ids) {
		log.info("array ids :" + Arrays.deepToString(ids));
		
		return "ex02Array";
	}
//배열리스트
@GetMapping("/ex02List")
	public String ex02List(@RequestParam("ids")ArrayList<String> ids) {
		log.info("ids" + ids);
		return "ex02List";
	}
```

객체안의 속성이 제대로 수집됨.(자동으로 타입을 변환해 처리한다!)(set하지 않아도 name은 null, age는 0이 기본값)



http://localhost:8090/sample/ex02List?ids=111&ids=222&ids=333 를 브라우저에 요청하면 각 배열원소를 받을 수 있다.





@RequestParam

- Controller 메소드의 파라미터와 웹 요청 파라미터를 매핑하기 위한 어노테이션이다. 웹에서 ids=111을 요청하면, Controller에서 ids를 받아 log에 출력시킨다.





객체리스트

- 객체를 List로 받는 클래스작성

```java
@Data
public class SampleDTOList {
	
	private List<SampleDTO> list;
	
	public SampleDTOList() {
		list = new ArrayList<>();
	}
}
```

sample/ex02Bean?list%5B0%5D.name=aaa&list%5B2%5D.name=bbb

해당 URL호출시 객체는 3개 생성되고, 각 객체에 대한 정보 출력이 됨.







#### @InitBinder

파라미터 수집 = 바인딩

변환가능 데이터는 자동으로 변환되지만 파라미터를 변환해서 처리해야하는 경우가 발생할 수도 있다. 2020-05-14라는 문자열을 Date타입으로 변환하는 작업이 그 예이다.

위의 예시는 @InitBinder을 이용해 처리할 수 있다.



예를 살펴보자

먼저, TodoDTO 클래스를 작성한다.

```java
@Data
public class TodoDTO {
	private String title;
	private Date dueData;
}
```



이를 처리할 initBinder을 이용하는 메소드 작성한다

```java
	@InitBinder
	public void initBinder(WebDataBinder binder) {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		binder.registerCustomEditor(java.util.Date.class, new CustomDateEditor(dateFormat, false));
	}
	
	@GetMapping("/ex03")
	public String ex03(TodoDTO todo) {
		log.info("todo: " + todo);
		return "ex03";
	}
```

http://localhost:8090/sample/ex03?title=test&dueData=2020-05-12 ->![initBinder](https://user-images.githubusercontent.com/55486644/81880523-aefc7580-95c8-11ea-9e35-4de9152b6997.JPG)



또는, @DateTimeFormat을 이용해 변환할 수 있다. 해당 경우엔 @InitBinder이 필요 없다. 형식만 맞으면 변환된다.

```java
@Data
public class TodoDTO {
	private String title;
	
	@DateTimeFormat(pattern = "yyyy-MM-dd")
	private Date dueData;
}

```





## 에러

```
Log4j에서 import가 제대로 읽히지 않는 에러가 발생했었다.
Log4j관련 설정 하위에 <scope> runtime</scope>를 지워주니 해결되었다.
runtime : 컴파일 시에는 필요하지 않지만 실행시에 사용되는 경우 사용한다. 이 옵션은 런타임, 테스트 시 classpath에 추가 되지만, 컴파일시에는 추가 되지 않는다.
```

## 스프링 #08 Controller의 리턴 타입



#### void

리턴타입을 void로 할 경우 해당 URL의 경로를 그대로 jsp 파일 이름으로 사용

```java
@GetMapping("/ex05")
public void ex05(){
	log.info("/ex05......");
}
```

![void타입 리턴](https://user-images.githubusercontent.com/55486644/81915467-94002480-960d-11ea-95ac-7bb4a4eb3060.JPG)

#### String

상황에 따라 다른 화면을 보여줄 경우가 있을 때 사용

redirect 또는 forward 키워드를 붙일 수 있다.





---

#### 객체 타입

VO나, DTO타입 등 여러 데이터가 들어간 객체로 지정 가능-> JSON 데이터를 만들어 내는 용도로 사용.





JSON

- JavaScript Object Notation
- 경량의 데이터 교환방식
- 데이터를 표시하는 표현방법(텍스트 형식일뿐임)
- 서버 - 클라이언트 교류간 많이 사용
- 사용하기 위해서 jack-son-databind 라이브러리 추가

```xml
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.4</version>
</dependency>

```





@ResponseBody를 통해 View로의 이동없이 데이터만 또는Json 데이터를 웹페이지에 전달할 수 있다. 

```java
	@GetMapping("/ex06")
	public @ResponseBody SampleDTO ex06() {
		log.info("/ex06..........");
		
		SampleDTO dto = new SampleDTO();
		dto.setAge(10);
		dto.setName("성상");
		return (dto);
	}
```

![json 출력](https://user-images.githubusercontent.com/55486644/81916691-1806dc00-960f-11ea-9c10-a4045639f5ba.JPG)



---

#### ResponseEntity 타입

MVC 매핑은 HttpServletRequest, Response를 직접 핸들링 하지 않아도 처리해주기 때문에 HTTP프로토콜 헤더를 다루지 않아도 된다

ResponseEntity를 통해 원하는 헤더 정보 또는 데이터 전달가능



```java
	
	@GetMapping("/ex07")
	public ResponseEntity<String> ex07(){
		log.info("/ex07.........");
		
		String msg = "{\"name\": \"홍길동\"}";
		
		HttpHeaders header = new HttpHeaders();
		header.add("Content-Type", "application/json;charset=UTF-8");
		
		return new ResponseEntity<>(msg, header, HttpStatus.OK);
	}
	
```

![headers보기](https://user-images.githubusercontent.com/55486644/81918011-eabb2d80-9610-11ea-8845-91d7d29bb5ca.JPG)

이렇게 헤더를 확인할 수 있다.


## 스프링 #09 파일업로드 처리

파일 업로드하는 방법에 대해 학습해보자.



pom.xml에 commons-fileupload 라이브러리를 추가한다.


```xml
<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.3</version>
</dependency>

```



그리고 파일이 임시로 업로드 될 폴더를 C하위에 upload/tmp로 생성한다.

그리고 servlet-context 파일에 아래와 같은 설정을 추가한다.

```xml
	<!--  File upload configuration -->
	
	<beans:bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<beans:property name="defaultEncoding" value="utf-8"></beans:property>
		<!-- 1024 * 1024 * 10 bytes 10MB -->
		<beans:property name="maxUploadSize" value="104857560"></beans:property>
		<!--  1024 * 1024 * 2bytes  2MB -->
		<beans:property name="maxUploadSizePerFile" value ="2097152"></beans:property>
		<beans:property name="uploadTempDir" value="file:/C:/upload/tmp"></beans:property>
		<beans:property name="maxInMemorySize" value="10485756"></beans:property>
	</beans:bean>
	
```

- maxUploadSize : 한 번의 Request로 전달 될 수 있는 최대 크기
- maxUploadSizePerFile : 한 파일의 최대 크기
- maxInMemorySize : 메모리 상에서 유지하는 최대 크기, 해당 크기 이상의 파일은 uploadTempDir에 임시 파일 형태로 보관된다.



```java
	@GetMapping("/exUpload")
	public void exUpload() {
		log.info("/exupload..........");
	}
	// 해당 내용 작성 후 jsp파일도 작성
```

```jsp
<form action="/sample/exUploadPost" method="post" enctype="multipart/form-data">

	<div>
		<input type='file' name='files'>
	</div>
	
	<div>
		<input type='file' name='files'>
	</div>
	
	<div>
		<input type='file' name='files'>
	</div>
	
	<div>
		<input type='file' name='files'>
	</div>
	
	<div>
		<input type='file' name='files'>
	</div>
	
	<div>
		<input type='submit' value="제출">
	</div>
</form>
```

![파일업로드](https://user-images.githubusercontent.com/55486644/81931312-d719c200-9624-11ea-82f1-d399cd3e0e00.JPG)



form action태그를 exUploadPost로 작성했으니 post방식의 맞는 메소드를 추가한다

```java
	@PostMapping("/exUploadPost")
	public void exUploadPost(ArrayList<MultipartFile> files) {
		files.forEach(file -> {
			log.info("--------------");
			log.info("name: " + file.getOriginalFilename());
			log.info("size: "+ file.getSize());
		});
	}
```



![파일 업로드 로그 기록](https://user-images.githubusercontent.com/55486644/81931617-5c04db80-9625-11ea-969c-0d2d626c6805.JPG)



제대로 업로드되어 ArrayList의 files가 데이터를 전달받고 이를 출력해주는 화면이다.



### JAVA로 설정하면

ServletConfig클래스에서,

mutipartResolver를 빈으로 등록하고 CommonsMultipartResolver 객체의 getResolver을 작성한다.



최종 업로드는 byte[]처리를 해야한다. 나중에 다뤄볼 예제.

## 스프링 #10  Controller의 예외처리

@ExceptionHandler, @ControllerAdvice를 이용한 처리

@ResponseEntity를 이용하는 예외 메시지 구성

```java
@ControllerAdvice
@Log4j
public class CommonExceptionAdvice{
	
	@ExceptionHandler (Exception.class)
	public String except(Exception ex, Model model) {
		
		log.error("Exception..... "+ ex.getMessage());
		model.addAttribute("exception", ex);
		log.error(model);
		return "error_page";
	}
}
```



@ControllerAdivice는 해당 객체가 스프링의 컨트롤러에서 발생하는 예외를 처리하는 존재임을 명시하는 용도

@ExceptionHandler은 해당 메소드가 ()들어가는 예외타입을 처리한다라는 의미. 즉, Exception.class을 지정했으므로, except()에서 모든 예외가 처리됨.

JSP에서도 에러 메시지를 보고 싶으면, Component-scan 패키지 경로를 추가해준다.



브라우저상에서 에러메세지를 확인하려면, 아래와 같은 코드를 작성한다.

```jsp
<%@ page language ="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ page session="false" import="java.util.*" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h4><c:out value="${exception.getMessage() }"></c:out></h4>
	
	<ul>
		<c:forEach items="${exception.getStackTrace() }" var="stack">
			<li> <c:out value="${stack}"></c:out></li>
		</c:forEach>
	</ul>

</body>
</html>
```



예외메시지가 출력되는지 확인하기 위해서, ex04에서 page같은 파라미터를 변환할 수 없는 다른값으로 지정한 후 호출해본다.

![에러메세지 on WEB](https://user-images.githubusercontent.com/55486644/81934268-a5efc080-9629-11ea-8093-6748540d1e42.JPG)





#### 404 에러페이지

500 메시지는 @ExceptionHandler를 이용해 처리하지만, 잘못된 URL을 호출할 때 생기는 404 메시지는 WAS 내부에서 발생하는 에러 처리방식을 따른다.



스프링 MVC의 모든 요청은 DispatcherServlet를 이용해 처리되므로 404에러도 같이 처리할 수 있도록, web.xml을 수정한다.

```xml
		<init-param>
			<param-name>throwExceptionIfNoHandlerFound</param-name>
			<param-value>true</param-value>
		</init-param>
```

<servlet>> 태그안에 상위 내용을 작성하고, CommonExceptionAdvice 클래스에 메소드를 추가한다.

```java
	@ExceptionHandler(NoHandlerFoundException.class)
	@ResponseStatus(HttpStatus.NOT_FOUND)
	public String handle404(NoHandlerFoundException ex) {
		return "custom404";
	}
```



그리고, custom404.jsp도 작성한다.



엉뚱한 URL로 접근하게되면 평상시 뜨는 에러 페이지가 아닌

![커스텀 에러 404](https://user-images.githubusercontent.com/55486644/81935713-0c75de00-962c-11ea-8ef4-b2d5b5ba8a39.JPG)

작성한 페이지로 출력되는 것을 확인할 수 있다.





---
###### 7. 학습 내용에 대한 개인적인 총평
- CRUD에 필요한 스프링 Controller의 파라미터 처리, Controller의 각 리턴타입에 대한 의미 그리고 파일 업로드, 에러페이지의 예외처리에 대해 학습했다.
- 지금까지 학습내용은 거의 설정에 관한 내용이었다. 이전까지 대충 인터넷을 보고 설정을 진행했는데 하나하나 의미도 모르고 복사 붙여넣기 했던 것이 아쉽다. 단지 설정인줄만 알았는데 그에 대한 이해가 덧붙였다면 스프링을 이해하고 개발하는데 훨씬 수월했을 것 같다.
- 책의 내용을 따라가면서 하려면 적어도 2주정도는 걸릴 것 같다. 충분한 시간을 투자하고 지금까지 배웠던 내용들을 잘 정리해서 프로젝트를 진행할 때 복습을 하면서 이용할 것이다.
###### 8. 다음 학습 계획
- 백준 문제풀이
- 웹 프로그래밍 학습
- 스프링 학습
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리