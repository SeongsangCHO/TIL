---
###### 1. 학습 날짜

- 2020-04-18(토)
 
---
###### 2. 학습시간

- 13:00 ~  16:45(자가)

---
###### 3. 학습 범위 및 주제

- 연결리스트 구현

---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 연결리스트 구현

---
###### 6. 과제 제출 repository 주소

http://13.125.198.2:3000/secho/ft_printf.git

---
###### 7. 상세 학습 내용

- 코드작성시간 : 2시간 
- 
## Linked List

연결리스트에서 2중포인터를 사용하는 이유???

- 단일 연결리스트에서 삽입, 삭제를 통해 head 포인터 값을 변화시킬 수 있다.

- t_list  **lst는, *lst의 주소를 가리키는 포인터다.

- ```c
  new->next = *head;
  *head = new; // 이처럼 *head시작포인터를 새로 생성한 new 주소로 변경할 수 있기 때문에 이중포인터로 선언
  ```

  

- **lst는가 가리키는 *lst의 주소는 lst의 첫번째 주소

- *lst는 head의 주소

*lst == NULL, lst == NULL

- *lst는 첫번째 주소, 헤드가 NULL이면, 빈 리스트!
- lst는 리스트 자체가 존재하지 않는다.

## 삽입

### add_node 처음 또는 맨 끝에 추가.

```c
t_list **lst;
t_list *curr;
if (lst == 0 || !(new = create_node(data))) // 리스트가 없거나, 노드생성에 실패했을때.
return ;
if (*lst == 0) // 빈 리스트이면, 새로 생성한 노드가 head노드.
{
	*lst = new;
	return ;
}
// 빈리스트가 아니라면,
curr = *lst; // curr의 주소를 맨 끝, tail로 이동 (curr->next가 NULL일때까지)
while (curr->next)
	curr = curr->next;
*lst->next = new; //tail의 다음주소를 new주소로. 맨끝에 노드 추가.
```

#### add_node_n n번째에 추가.

```c
t_list **head;
t_list *new;
t_list *curr;
int 	idx;

if (head == 0 || !(new = malloc(sizeof(t_list))))
	return ;
if (*head == 0)
{
	new->next = *head;
    *head = new;
}
curr = *head;
idx = 0;
while (curr->next && idx < n - 1)
{
    curr = curr->next;
    idx++;
}
new->next = curr->next;
curr->next = new;
```

## 삭제

head를 삭제할때, tail을 삭제할때, 그외를 삭제할때 3가지 분기를 나누어서 생각한다.

- head를 삭제할 때,

```c
void delete_node(t_node **head, int n)
{
	t_node *p;
	if (n == 1) //head일때,
	{
		p = *head;//임시노드의 주소를 head로 설정.
		*head = p->next; // 현재 head의 주소를 head 다음의 주소로 지정
		free(p);// 원래 head 삭제
		return ;
	}
}
```

- 중간, tail을 삭제할 때,

```c
t_node *q;
t_node *p;
int	   idx;
idx = 0;

...
    else
    {
        while (p != NULL && idx < n - 1)
        {
            q = p;
            p = p->next;
            idx++;
        }
        if (p == NULL)
        {
            prev->next = NULL;
            return ;
        }
        else // 중간 노드 삭제.
        {
            q->next = p->next;
            free(p);
            return ;
        }
    }

```

## 
---
###### 8. 학습 내용에 대한 개인적인 총평

- 단일연결리스트의 삽입, 삭제, 출력을 이해하고 구현했다. 연결리스트의 기본 동작은 삽입, 삭제, 수정, 검색이다. 수정과 검색을 마저 학습한 후 구현하면 될 것 같다.
이후 4가지기능을 충족하고 이중연결리스트, 순환연결까지 마무리 한 뒤, 백준문제를 해당 개념을 이용해 풀고, 깃에다가 정리할 계획이다.
printf는 천천히 진행할 계획이다.
5월달 전으로 자료구조(트리까지)를 계속 학습할 계획이다.

---
###### 9. 다음 학습 계획
- 자료구조 학습
- 평가진행하기
- 내용 정리