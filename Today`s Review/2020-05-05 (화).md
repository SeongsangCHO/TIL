---
###### 1. 학습 날짜

- 2020-05 -05(화)
 
---
###### 2. 학습시간

- 14:00 ~ 19:00 (자가)

---
###### 3. 학습 범위 및 주제

- 백준 문제풀이
---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 백준 문제풀이

---
###### 6. 상세 학습 내용

- 코드작성시간 : 4 시간
## SORT

simple, slow

- Bubble sort
- Insertion sort
- Selection sort

fast

- Quick sort
- Merge sort
- Heap sort

O(n)

- Radix sort



출처: https://ict-nroo.tistory.com/52 [개발자의 기록습관]

- Bubble sort

인접한 두 원소를 검사하여 정렬하는 알고리즘

1,2 2,3 3,4씩 짝지어, 마지막-1, 마지막원소를 비교하여 정렬한다.

1회전을 수행하면 가장 큰 원소가 맨 뒤로 이동하고, 회전이 돌때마다 매회의 마지막원소는 검사에서 제외된다.

- Insertion sort

두번째 원소부터 시작하여, 그 앞의 자료와 비교해 삽입 위치를 지정한다.

삽입위치를 찾으면, 이 전의 인덱스로 넘어가서 다시 비교하고, 자신의 위치를 찾아 들어간다.

```java
	for(int i=1; i<n; i++) {
		key=num[i];
		j=i-1;
		while(j>=0 && num[j]>key) {
			num[j+1] = num[j];
			j--;
		}
		num[j+1]=key;
	}
```

### 1193

무한히 큰 배열에 다음과 같이 분수들이 적혀있다.

| 1/1  | 1/2  | 1/3  | 1/4  | 1/5  | …    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 2/1  | 2/2  | 2/3  | 2/4  | …    | …    |
| 3/1  | 3/2  | 3/3  | …    | …    | …    |
| 4/1  | 4/2  | …    | …    | …    | …    |
| 5/1  | …    | …    | …    | …    | …    |
| …    | …    | …    | …    | …    | …    |

이와 같이 나열된 분수들을 1/1 -> 1/2 -> 2/1 -> 3/1 -> 2/2 -> … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.

X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.

- 먼저 , 이 문제를 접했을 때, 명령어 별로 접근하려고했다.

1. 오른쪽으로 움직였을때, Right + 1
2. 좌하 대각선으로 움직였을때, Left + 1, Right - 1
3. 아래로 움직였을때, Left + 1
4. 우상 대각선으로 움직일때, Left - 1 , Right + 1
5. 한 cycle이 돌때마다, 2,4번의 명령어 횟수는 + 1 씩 증가한다.

그러나, 너무 지저분하게 되고, 효율도 안좋기때문에 다른 방법을 생각해보았다.

1. 대각선을 일렬로 세우게 되면 각 분수들의 갯수는 1, 2, 3, 4, 5 ... 1개씩 증가하게 된다.
2. X번째를 입력으로 받아 해당 값이 위치한 대각선의 줄 수를 cnt하고, 어느 부분에 위치한지 찾아낸다.
3. 해당 인덱스의 Left, Right는 짝수마다 Left는 1,2,3,4,5.. Right는 5,4,3,2,1 같이 규칙성이 있으므로 이를 활용한다.
4. 줄수를 찾는 방법은, sum =1+2+3+4+5...로 X보다 크거나 같은 값을 찾을 때, 반복문을 종료하는 방법으로 찾고, 이때 더해진 sum - X를 하여 뒤에서부터 몇번째인지 찾아낸다.
5. 뒤에서 부터 찾으므로, Left, Right는 3번의 순서와 반대로 진행하면 된다.



### 2869

달팽이는 V미터만큼 올라가야한다.

낮에는 A미터 ++, 밤에는 B미터--

모두 올라가려면 얼마나 걸릴까.

- 입력은 A B V순서로 - 
- 예제 2 1 5 = > 4일

1일차 밤 1미터

2일차 밤 2미터

3일차 밤 3미터

4일차 낮 5미터

2 [1] 3 [2] 4 [3] 5 

+되는 시점 후에 비교문

- 하루에 올라갈 수 있는 거리는 A - B이다.
- 도착하는 마지막날에는 B만큼 내려오지 않는다.
- 고로 최종적으로 이동하는 거리는 A + (A - B) * N(일수)이다.
- V - A = (A - B) * N 즉,
- N = (V - A) / (A - B) 이므로 일 수를 구할 수 있다.
- A-B로 나누었을때, 나누어 떨어지지 않는 경우에서는 + 1 일만큼 더해준다.

---
###### 7. 학습 내용에 대한 개인적인 총평

- 백준문제를 어느정도 풀고, 스프링을 진행하려했는데 한 문제에서 막히니까 너무 시간을 오래 썼다.
- 정렬에 대해서 다시 복습을 진행했고 이를 통해 구현했다.
- 하루에 한 챕터씩 끝내고자하는데, 구현력이 부족해 다양한 메소드를 응용하는데 제약이 있는 것 같다. 그래서 최대 1시간가량 고민을 하고, 안되면 자료를 참고해 진행하려고 한다.

---
###### 8. 다음 학습 계획
- 백준 문제풀이
- 스프링 학습
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리