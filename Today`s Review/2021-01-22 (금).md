

###### 1. 학습 날짜

- 2021 - 01 - 22(금)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 필로소퍼 3

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- 필로소퍼 3번 구현

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간
- 쓰레드말고 프로세스로 구현해야함
- 기존 쓰레드는 ph구조체를 공유했는데 공유자원없이 구현해야함.
- 포크가 가운데에 놓여있는 것은 같음.

이름있는 세마포어를 사용해서 다른 프로세스가 해당 세마포에 접근할 수 있도록 하면된다. 이름없는거 생성 ⇒sem_init , 있는 건 sem_open

- 지정된 세마포어(named semaphore)는지정된 위치 이름을 가지고 여러 개의 프로세스가 이 지정된 위치에 존재하는 세마포어에 접근하는 방식입니다.

### int sem_destroy(3)

\- 지정되지 않은 세마포어를 제거.

\- 만일 생성시 프로세스 간에 공유가 가능한 세마포어를 만들고, 다른 프로세스가 wait 상태에 있는 중에 제거되면 모두 에러 처리됩니다.

### int sem_close(3)

\- 할당된 메모리를 제거.

### int sem_unlink(3)

\- 시스템에 만들어진 세마포어 이름 자체를 삭제.

\- 즉, sem_close는단순히 지정된 세마포어와의 연결을 끊어버리는 것이고,

- sem_unlink는 아예 삭제하는 것입니다.
- sem_unlink로 삭제하면 해당 세마포어를 다루고 있던모든 프로세스는 에러 처리됩니다.

philo_three에서는 철학자들이 스레드가 아닌 프로세스로 동작하게 됩니다. 그에 따라 프로세스간에 공유가 불가능해집니다. 프로세스간에 데이터를 공유하기 위해서는 파일을 사용하는 방식과 공유 메모리를 사용하는 방식이 있지만 허용된 함수 내에 해당 방식을 사용할 수 없기 때문에 공유되는 자원 없이 철학자를 구현해야 합니다.

하지만 모든 포크가 테이블 가운대에 놓여 있다는 점과 이름 있는 세마포어의 경우 파일을 사용한다는 점에서 프로세스간에 세마포어를 사용하여 포크에 접근할 수 있습니다.

메인 프로그램은 철학자일 필요가 없기 때문에 어떤 방식으로 구현할지는 자유롭게 구상하시면 됩니다.

### **프로세스 관련 명령어[Permalink](https://jiiiiind.github.io/42Seoul/4Circle/Philosopher/#프로세스-관련-명령어)**

### **fork, exit, kill[Permalink](https://jiiiiind.github.io/42Seoul/4Circle/Philosopher/#fork-exit-kill)**

위의 명령어들은 앞 서클의 미니쉘에서 다루었을 것이기 때문에 따로 다루지 않음 kill을 사용하기 위해서는 signal.h를 포함시켜야 함

### **pid_t waitpid(pid_t pid, int \*statloc , int options)[Permalink](https://jiiiiind.github.io/42Seoul/4Circle/Philosopher/#pid_t-waitpidpid_t-pid-int-statloc--int-options)**

해당 함수도 미니쉘에서 다룰 수 있지만 다른 wait 함수들도 있었기에 설명합니다.

`"sys/wait.h"` 헤더가 필요함

**parameter**

- pid_t pid
  - pid == -1
    - 임의의 자식 프로세스를 기다림
  - pid > 0
    - 프로세스 ID가 pid인 자식 프로세스를 기다림
  - pid < -1
    - 프로세스 그룹 ID가 pid의 절댓값과 같은 자식 프로세스를 기다림
  - pid == 0
    - waitpid를 호출한 프로세스의 프로세스 그룹 PID와 같은 프로세스 그룹 ID를 가진 프로세스를 기다림
- int *statloc
  - 자식 프로세스가 정상적으로 종료된 경우
    - WIFEXITED(statloc) 매크로가 true를 반환
    - 하위 8비트를 참조하여 자식 프로세스가 exit, _exit, _Exit에 넘겨준 인자 값을 얻을 수 있음
    - WEXITSTATUS(statloc)
  - 자식 프로세스가 비정상적으로 종료(시그널에 의한 종료)
    - WIFSIGNALED(statloc) 매크로가 true를 반환
    - 비정상 종료 이유를 WTERMSIG(statloc) 매크로를 사용하여 구할 수 있음
  - waitpid 함수 오류
    - 함수의 반환 값이 -1이다.
    - ECHILD
      - 호출자의 자식 프로세스가 없는 경우
    - EINTR
      - 시스템 콜이 인터럽트 되었을 경우
- int options
  - WCONTINUED
    - 중단 되었다가 재개된 자식 프로세스의 상태를 받음
  - WNOHANG
    - 기다리는 PID가 종료되지 않아서 즉시 종료 상태를 회수 할 수 없는 상황에서 호출자는 차단되지 않고 반환값으로 0을 받음
  - WUNTRACED
    - 중단된 자식 프로세스의 상태를 받음(블럭됨)

**return value**

성공시 프로세스 id를 반환하고, 실패시 -1을 반환 오류에 대해서는 statloc이 가지고 있음

### **좀비 프로세스와 고아 프로세스[Permalink](https://jiiiiind.github.io/42Seoul/4Circle/Philosopher/#좀비-프로세스와-고아-프로세스)**

부모 프로세스가 자식 프로세스보다 먼저 종료될 경우, 자식은 고아 프로세스가 됩니다.

자식 프로세스가 종료되었지만 부모 프로세스가 자식의 종료 상태를 회수하지 않을 경우 자식 프로세스는 좀비 프로세스입니다.

해당 과제에서 고아 프로세스가 나올 일은 없겠지만 그래도 같이 알아두는게 좋습니다.

### **고아 프로세스[Permalink](https://jiiiiind.github.io/42Seoul/4Circle/Philosopher/#고아-프로세스)**

부모가 자식보다 먼저 종료된 경우, init 프로세스가 자식의 새로운 부모가 됩니다.

종료되는 프로세스가 발생할 때 커널은 이 프로세스가 누구의 부모인지 확인 후, 커널이 자식 프로세스의 부모 프로세스ID를 1로 바꿔 줍니다.

init 프로세스의 경우 유닉스 계열의 운영체제에서 부팅 과정 중 생성되는 최초의 프로세스이며, 시스템이 종료될때까지 계속 살아있는 데몬 프로세스입니다.

### **좀비 프로세스[Permalink](https://jiiiiind.github.io/42Seoul/4Circle/Philosopher/#좀비-프로세스)**

자식 프로세스가 exit 시스템콜을 호출하면서 종료되면 이 프로세스에 관련된 모든 메모리와 리소스가 해제되어 다른 프로세스에서 사용할 수 있게 됩니다. 하지만 종료 이후에도 부모 프로세스가 자식 프로세스의 상태를 알고 싶어할 수 있기 때문에 커널은 최소한의 정보(프로세스 ID, 프로세스 종료 상태 등)를 가지고 있게 됩니다.

부모 프로세스가 좀비 프로세스의 종료 상태를 회수하게 되면(wait 시스템콜 호출) 좀비 프로세스는 제거됩니다.

좀비 프로세스가 쌓이게 되면 리소스의 유출을 야기할 수 있기 때문에 좀비 프로세스 상태를 오래 유지하지 않도록 부모 프로세스는 wait 시스템 콜 함수를 사용하여 자식 프로세스의 종료 상태를 읽어들이는 것이 필요합니다.

---

###### 7. 학습 내용에 대한 개인적인 총평

- 쓰레드를 사용하지않고 자식프로세스를 생성해 해결하는 문제. 이름있는 세마포어를 사용하면 자식프로세스에서도 접근 가능하기 때문에 자식프로세스코드 작성

###### 8. 다음 학습 계획

- js