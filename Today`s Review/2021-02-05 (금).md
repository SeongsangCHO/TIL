

###### 1. 학습 날짜

- 2021 - 02 - 05(금)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- Cpp08

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- cpp08

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# 자료구조 구현인가.

# vector

**vector 컨테이너는 자동으로 메모리가 할당되는 배열.**

- **vector<int> v;**비어있는 vector v를 생성합니다.
- **vector<int> v(5);**기본값(0)으로 초기화 된 5개의 원소를 가지는 vector v를 생성합니다.
- **vector<int> v(5, 2);**2로 초기화된 5개의 원소를 가지는 vector v를 생성합니다.
- vector<int> v1(5, 2);**vector<int> v2(v1);**v2는 v1 vector를 복사해서 생성됩니다.

룰.

- 이 특정 주제에서 해결하도록 요청받은 많은 문제는 표준 컨테이너를 사용하지 않고 표준 알고리즘을 사용하지 않음으로써 해결할 수 있음을 알 수 있습니다. 그러나 그것들을 사용하는 것이 목표이며, 적절한 곳에서 표준 컨테이너와 알고리즘을 사용하기 위해 모든 노력을 기울이지 않으면 매우 나쁜 점수를 받게 될 것입니다. 너무 게으르지 마세요.

# ex00

### 연관 컨테이너의 종류

- STL에서는 연관 컨테이너로 다음과 같은 클래스 템플릿을 제공합니다.
  1. set
  2. multiset
  3. map
  4. multimap

## key, value를 저장하는 map

- 연관컨테이너 중 하나. 연관 컨테이너(associate container)는 키(key)와 값(value)처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너입니다.
- **Map** - map은 **key**와 **value**로 이루어져있으며 이는 pair 객체 형태로 저장됩니다.
- **Unique Key** - key는 고유한 값이므로 **중복이 불가능** 합니다. (중복 key는 multimap 에서 가능합니다.)
- **Ordered** - map도 set과 마찬가지로 **삽입이 되면서 자동으로 정렬**이 됩니다. (default는 less/오름차순 입니다.)
- **Allocator-aware** - map container는 저장공간의 필요에 따라서 allocator 객체를 사용합니다. (동적할당 합니다.)

기본 생성 방법은 :

```jsx
**map< [Data type1], [Data type2] > [변수이름];**

map<int, int> m1;
map<string, int> m2;

우리가 만들건 map<T, int>

template<typename key>
std::map<key, int>::...
```

### find 함수

- InputIterator find(InputIterator first, InputIterator last, const T& val);

  - first, last 이터레이터 범위만큼, val을 찾겠다.  (주소를 넣어도됨)
  - 원소가 없을 경우 last가 리턴됨

  ```jsx
  // using std::find with vector and iterator:
    std::vector<int> myvector(myints, myints + 4);
    std::vector<int>::iterator it;
  
    it = find(myvector.begin(), myvector.end(), 30);
    if (it != myvector.end())
      std::cout << "Element found in myvector: " << *it << '\\n';
    else
      std::cout << "Element not found in myvector\\n";
  ```

- easyfind.hpp main.cpp 제출

- 첫 스타트로 시작하기 좋은........ easyfind라는 템플릿 함수를 작성해라. T와 int를 매개변수로 갖는다.

- T가 int의 컨테이너라고 가정하고 첫 번째 매개변수에서 두 번째 매개변수의 첫 항목을 찾는다. (?)

- 찾을 수 없는경우 예외를 발생시키(거나) 에러 리턴값을 반환해라. 표준 컨테이너 작동방식에서 아이디어를 얻어라..

# ex01 Span

- span.cpp, span.hpp, main.cpp
- N ints를 저장할 수 있는 클래스를 만들어라.
- N은 unsigned int이고 생성자의 단일 파라미터로 사용된다.
- 이 클래스는 `addNumber` 라는 `하나의 숫자를 저장하는 함수가 있어야한다.`
  - 이미 N개가 저장되어있는 경우 새 번호 추가시 예외가 발생함.
- `shortestSpan, longestSpan` 함수를 만들어라.
  - 각 객체의 저장된 넘버들 사이에서 최단, 최장 범위를 찾아 반환한다.
  - 저장된 숫자가 없거나, 하나만 있으면 범위가 없으므로 예외가 발생한다.
- 최소한 10000 개의 숫자로 테스트해야합니다. 더 많은 것이 좋은 것입니다. 반복자 범위를 전달하여 숫자를 추가 할 수 있다면 매우 좋을 것입니다.

for문 2번돌려서 차가 가장 작은것, 큰것 구하면 되는듯.

```jsx
int main()
{
	Span sp = Span(5); //5개 숫자 갖겠음.
	sp.addNumber(5);
	sp.addNumber(3);
	sp.addNumber(17);
	sp.addNumber(9);
	sp.addNumber(11);

// 3 5 9 11 17
// 3-5가 가장 작은 범위,
// 3-17이 가장 넓은 범위
	std::cout << sp.shortestSpan() << std::endl;
	std::cout << sp.longestSpan() << std::endl;
}

$> ./ex01
2
14
$>
```

# ex02 Mutated abomination

- mutantstack.cpp mutantstack.hpp main.cpp

이제 애피타이저가 완성 되었으니 역겨운 일을 해보겠습니다. ⇒ zz.. std :: stack 컨테이너는 매우 멋지지만 반복 할 수없는 유일한 STL 컨테이너 중 하나입니다. 유감 이네요. 그러나 우리가 단순히 신을 연기하고 우리가 좋아하는 것을 추가하기 위해 그것을 도살 할 수 있는데 왜 괜찮을까요? 이 능력을 std :: stack 컨테이너에 연결하여이 중대한 불의를 고칠 것입니다. std :: stack 측면에서 구현 될 MutantStack 클래스를 만들고 모든 멤버 함수를 제공합니다.이 클래스 만 반복자를 제공합니다. 다음은 코드의 예입니다. 출력은 예를 들어 MutantStack을 std :: list로 바꾼 것과 동일해야합니다. 물론 당신은 테스트를 제공 할 것입니다 이 모든 것이 주요 기능에 있습니다.

스택 구현인듯.

```jsx
int main()
{
	MutantStack<int> mstack;
	mstack.push(5);
	mstack.push(17);
	std::cout << mstack.top() << std::endl;
	mstack.pop();
	std::cout << mstack.size() << std::endl;
	mstack.push(3);
	mstack.push(5);
	mstack.push(737);
	//[...]
	mstack.push(0);
	MutantStack<int>::iterator it = mstack.begin();
	MutantStack<int>::iterator ite = mstack.end();
	++it;
	--it;
	while (it != ite)
	{
		std::cout << *it << std::endl;
		++it;
	}
	std::stack<int> s(mstack);
	return 0;
}
```

---

###### 7. 학습 내용에 대한 개인적인 총평

- ex02빼고 모두 구현했다. 남은건 제출만 하면 될 듯하다.

###### 8. 다음 학습 계획

- js