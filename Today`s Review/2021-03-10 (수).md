

###### 1. 학습 날짜

- 2021 - 03 - 10(수)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 리액트 기초 정리

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- 리액트 기초 정리

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# React 기초질문



---





### 컴포넌트란?

앱을 다루는 최소단위로써 데이터(state, props)를 입력받아 DOM노드를 출력하는 함수.



### State, Props?

컴포넌트에서 다루는 데이터.

state는 컴포넌트 내부에서 선언하고 이를 변경할 수 있다.

props는 부모가 자식에게 전달하는 값이다.





### 불변성이란?

기존의 값을 그대로 유지하면서 새로운 값을 추가하는 것으로 객체생성 이후 그 상태를 변경할 수 없는 디자인 패턴.



원시타입은 함수의 인자로 넣었을 때 메모리에 새로 할당해 이를 전달하는 `call by value`이지만, 객체나 배열의 경우 레퍼런스를 전달하는 `call by reference` 방식이 사용된다.



어떤 함수가 객체의 프로퍼티의 값을 변경했다고 해보자.

나중에 사이즈가 커졌을 때 어디서 어떤 함수로 인해 이 프로퍼티값이 변경되었는지 디버깅하기 어렵다. 또 리액트에서는 상태변화를 통해 리랜더링하는 과정을 사용하는데, 프로퍼티값이 변경되었음에도 불구하고 동일한 레퍼런스이기 때문에 값이 변경되도 리랜더링되지 않는다.



간략하게 줄이면, 디버깅하기 어렵고, 상태변화를 추적할 수 없다.

언제? 배열이나 객체처럼 `call by reference` 에서 값을 변경했을 때.

왜? 같은 레퍼런스이므로 값이 변경되어도 변화를 감지할 수 없어서.



리액트에서 불변성을 지킨다는 것은 값이 변경되었을 때, 원본 상태를 훼손시키지 않고, 배열, 객체의 레퍼런스를 새로 반환하는 것과 같다고 생각한다.

그러나 흔히 사용하는 `spread, object.assgin`은 얕은 복사를 통해 1depth만큼의 복사만 되고 프로퍼티내 객체가 존재하면 이를 같은 레퍼런스로 보기에 2depth 비교는 할 수 없다.



불변을 지키면서 2depth구조의 객체 상태를 변화시키기 위해서는

```js
let state = {
	...state,
	name:{...name}
}
```

위와 같은 방식으로 중첩해서 사용해야한다.

이와 같이 얕은 비교를 spread연산자로 할 수 있다.

만약 10depth면 저 과정을 9번 더 해야한다. (끔찍스)



그래서 `Immer`와 같은 불변성 유지를 편하게 해주는 라이브러리를 사용한다.

[참고](https://evan-moon.github.io/2020/01/05/what-is-immutable/)



### 순수컴포넌트

컴포넌트는 항상 render를 다시 실행하지만, 동일한 props, state에 대해 동일한 결과를 랜더링한다면 render를 다시 실행하지 않아 성능향상을 누릴 수 있다.

HOC로써 props, state의 변경을 확인하는 `shouldComponentUpdate`를 구현하지 않고 내부에서 수행한다.

얕은비교를 하므로 깊은 차이가 있을 때 사용에 주의해야한다.



잘못 사용하는 예시(컴포넌트보다 성능이 더 나빠질 수 있다.)

- 인라인함수를 render메소드 내에 쓰면 매 렌더링마다 함수인스턴스가 새로 생성된다.

- 매 render실행마다 props로 넘어오는 함수가 모두 다르다는 것이고 얕은 비교를 통해 항상 다르다는 결과를 반환한다.

- ```js
  <Input onChange={()=>setState()}/>
  - 함수 인스턴스가 매 랜더링마다 생성.
  - props.onChange가 이전 레퍼런스와 다름
  - 매 랜더링마다 리랜더링됨.
  ```







### Portal Component

컴포넌트는 계층적으로 부모 하위에 있다.

모달과 같은 창은 부모 위에서 출력되어야 하는데 계층구조상 하위에 있기 때문에 position, z-index를 사용해도 위로 덮어씌우며 출력될 수 없다.

이때 사용되는 것이 Portal Component다.

논리적으로 하위컴포넌트여야 하는데 시각적으론 상위 컴포넌트를 덮어야할 상황일 때 사용한다.

[pure, portal Component 참고](

---

###### 7. 학습 내용에 대한 개인적인 총평

- 기초가 중요하므로 기초를 쌓으면서 나아가기.

###### 8. 다음 학습 계획

- 리팩토링