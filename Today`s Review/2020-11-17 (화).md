

###### 1. 학습 날짜

- 2020 - 11 - 17(화)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- OS, 동기화도구

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- 동기화 도구들의 배경, 임계구역과 피터슨해결안에 대해 정리

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

## 보충2__동기화 도구들

<br>

### 보충2.1 :fallen_leaf: 배경　


다음 그림과 보기를 참고해 1, 3번 문제의 빈칸을 채우고 2번 문제에 답해주세요.

![](https://images.velog.io/images/jehjong/post/a2b067af-55c5-4dde-a1d4-bf065fe44070/image.png)

> <보기>
>
> `경쟁 상황(race condition)`,
>
> `동기화`, `프로세스`, `조작`, `진행`, `조정`
>
> `증가`, `감소`
>
> `4`, `5`, `6`, `count`

1. 두 개의 프로세스 생산자와 소비자 프로세스는 각각 count++와 count--를 수행합니다. count라는 변수는 버퍼에 새 항목을 추가할 때마다 `증가`되고 버퍼에서 한 항목을 꺼낼 때마다 `감소`되는 것으로, 현재 count는 5입니다. 다음 그림에서 register1과 register2는 한 CPU만 접근할 수 있는 로컬 레지스터 중 하나입니다. count++와 count-- 코드를 병행하여 실행해 아래처럼 count가 `4`이/가 되었습니다. (빈칸채우기)

   > 증가, 감소, 4


2. count 값이 정확한가요? 정확하지 않다면 실제로는 몇 개의 버퍼가 채워져 있어야하며 왜 부정확한지 설명해주세요. (주관식)

   >count++와 count--를 병행하게 실행하는 것은 해당 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 동일합니다. 따라서 count는 실행 순서에 따라 4나 6의 부정확한 값을 갖게되며 실제로는 5개의 버퍼가 채워져 있습니다. 이는 두 개의 프로세스가 동시에 변수 count를 조작하도록 허용했기 때문입니다.


3. `경쟁 상황(race condition)`이란 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황입니다. `경쟁 상황`으로부터 보호하기 위해 한순간에 하나의 프로세스만이 변수 `count` 를 조작하도록 보장해야하며, 이를 위해 프로세스들이 `동기화`되록 할 필요가 있습니다. (빈칸채우기)

   > 경쟁 상황, 경쟁 상황, count, 동기화

</div>
</details>
<br><br>


### 보충2.2 :fallen_leaf:  임계구역 문제　

1. 각 프로세스는 _____ 이라고 부르는 코드 부분을 포함하고 있고 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.
**임계구역 (critical section)**

2. _______는 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 시용할 수 있는 프로토콜을 설계하는 것이다.
**임계구역 문제**

3. 임계구역 문제를 해결하기 위해서는 다음 세가지 요구 조건을 충족시켜야 한다.
  - ________: 임계구역에는 동시에 한 프로세스만 접근가능함
  - ________: 유한한 시간 내에 임계구역에 들어갈 프로세스를 정해야함
  - ________: 프로세스가 임계구역을 들어가기 위한 요청 이후 실제 진입까지의 과정이 유한한 시간내에 일어나야함 (스케쥴링에서 기아문제같은것이 일어나지 않는것을 말하는 듯) 
**상호 배제(Mutual Exclusion)**
**진행(Progress)**
**한정된 대기(Bounded Waiting)**

</div>
</details>
<br><br>

### 보충2.3 :fallen_leaf:  Peterson의 해결안 

<img width="1294" alt="스크린샷 2020-11-08 오후 10 45 33" src="https://user-images.githubusercontent.com/53321189/98490558-2f005100-2275-11eb-80ae-23c9553eff69.png">



#### 피터슨 해결법의 단점은 무엇인가요?
> `busy waiting`으로 자원 낭비. <br>
> `busy waiting`이란 대기를 하는 동안 실제로 하는 일은 없는데 CPU를 계속 사용하며 대기하는 것으로, spin lock이라고도 한다.

#### 피터슨 해결법의 한계는 무엇인가요?
> 데이터 무결성 문제를 일으킬 수 있음 / 상호배제 조건 미달 <br>
> 현대적인 아키텍쳐에서는 성능 향상을 위해 작업 순서를 바꿀 수 있기 때문에 <br>
> 다중스레드가 데이터를 공유하는 과정에서 실행할 명령어들의 순서를 바꿔버리면 상호배제 조건이 충족되지 않음. 

</div>
</details>
<br><br>

---

###### 7. 학습 내용에 대한 개인적인 총평

- OS 스터디에서 나온 문제 풀고 개념 학습

###### 8. 다음 학습 계획

- 동기화 도구 