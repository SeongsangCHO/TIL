---
###### 1. 학습 날짜

- 2020-05 -06(수)
 
---
###### 2. 학습시간

- 10:00 ~ 16:00  22:00 ~ 24:00(자가)

---
###### 3. 학습 범위 및 주제

- 백준 문제풀이 및 정렬 학습
---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 백준 문제풀이 및 정렬 학습

---
###### 6. 상세 학습 내용

- 코드작성시간 : 4 시간
## Comparable, Comparator



- Comparable

  - 객첵간의 일반적인 정렬이 필요할때, Comparable인터페이스를 확장하여, 정렬 기준을 정의하는 compareTo()를 구현

  ```java
  public class EX_Comparable {
  
  	public static void main(String[] args) {
  		// TODO Auto-generated method stub
  		String [] hobby = new String[] {"Fishing", "Aerobic", "Baseball", "Dancing","Ctype"};
  		String [] name = new String[] {"김성균","박보검","한경섭","나인재","마피아"};
  		String [] number = new String[] {"33","2","1","99","0"};
  		
  		Arrays.sort(hobby);
  		Arrays.sort(name);
  		Arrays.sort(number);
  		for(int i = 0 ; i < 5; i ++) {
  			System.out.print(hobby[i]);
  			System.out.print(name[i]);
  			System.out.println(number[i]);
  			//기본적인 정렬 기준을 구현하는데 사용.
  		}
  		//ArrayList를 이용하면 Arrays.sort()가아닌, Collections.sort()적용
  		ArrayList<String> sportList = new ArrayList<String>();
  		sportList.add("Soccer");
  		sportList.add("Aerobic");
  		sportList.add("Baseball");
  		sportList.add("Ctype");
  		Collections.sort(sportList);
  		
  		for(int i = 0; i <sportList.size(); i ++)
  			System.out.print(sportList.get(i) +" ");
  		
  	}
  }
  ```

  - 값이 하나인 String , ArrayList는  각각 sort메소드가 동작하는 것을 확인할 수 있다. 그렇다면 객체도 마찬가지로 동작할까?

  ```java
  public class EX_Comparable_object {
  
  	public static class SoccerPlayer implements Comparable<SoccerPlayer>
  	{
  		private String name;
  		private int age;
  //getter, setter, 생성자 생략
  		@Override
  		public int compareTo(SoccerPlayer o) {
  			return name.compareTo(o.getName());//A,B,C순으로 출력된다.
  		}
  		
  	}
  	public static void main(String[] args) {
  	
  		ArrayList<SoccerPlayer> playerList = new ArrayList<SoccerPlayer>();
  		
  		SoccerPlayer p1 = new SoccerPlayer("Cgodmessi", 22);
  		SoccerPlayer p2 = new SoccerPlayer("Bmenaldo", 25);
  		SoccerPlayer p3 = new SoccerPlayer("Ajisung", 23);
  		
  		playerList.add(p1);
  		playerList.add(p2);
  		playerList.add(p3);
  		
  		Collections.sort(playerList);
          // List<T>를 인자로 받고 있는데 List에 들어가는 객체는 java.lang.Comparable을 구현한 클래스의 인스턴스여야 함- implement Comparable<인스턴스>
  		for(int i = 0; i < playerList.size(); i++)
  			System.out.println(playerList.get(i).getName());
  	}
  
  }
  
  ```

  

- 객체를 원소로 가진 List를 정렬하고자하면, 인터페이스를 구현해야한다 = compareTo(Object obj)메소드를 오버라이딩 해야한다. 리턴 값에 따라, 정렬 기준을 정할 수 있다.

- 인자로 전달된 값이 작으면 양의정수, 같으면 0, 크면 음의 정수를 반환



즉, 오름차순, 내림차순, 사전순 등의 정렬순서로 정렬할 수 있는 방법을 제시한다.

그렇다면, 사용자가 요구하는 임의의 기준으로 정렬하고 싶으면??

## Comparator

- 해당 인터페이스를 구현하면 임의기준을 구현해 원하는 방식으로 정렬할 수 있다.
- compare()메소드를 오버라이딩한다.
- 마찬가지로, Comparator를 상속받아(implements (부모의 메소드를 반드시 오버라이딩해야함(다중상속가능), extend(abstract클래스상속에 이용)))



```java
public class EX_Comparator {

	public static class Person
	{
		private String name;
		private int age;
		//get,setter 생성자 생략.
	public static void main(String[] args) {
		class name implements Comparator<Person>{
			@Override
			public int compare(Person p1, Person p2)
			{
				return p1.getAge() > p2.getAge() ? 1 : p1.getAge() < p2.getAge() ? -1 : 0;
			} // 반환값에 따라, 기준 정의 가능.
		}
		// TODO Auto-generated method stub
		List<Person> nameList = new ArrayList<>();
		
		nameList.add(new Person("Hwang", 27));
		nameList.add(new Person("Cho", 25));
		nameList.add(new Person("Ai", 24));
		

		System.out.println("정렬 전"+nameList.get(0).age); // 27
		Collections.sort(nameList, new name());
		System.out.println("정렬 후"+nameList.get(0).age); // 24
    }
}

```

- 퀵정렬에 대해 구현했다.

---
###### 7. 학습 내용에 대한 개인적인 총평

- 정렬과 몰랐던 정렬방법을 배우게 되었다. compa"*"인터페이스를 구현하면 개발자가 원하는 기준으로 정렬이 가능하다.
- 일정 변경으로.. 정해놨떤 스프링 CRUD기간을 조금 미루어야겠다. 자바에 대해서 조금은 안다고 생각했는데, 컬렉션이던지 자료형조차 모르고, 입출력의 방법에 대해서도 제대로 인지하지 못했다. BufferedReader, StringBuilder, StringBuffer 등 미숙한 부분이 많다. 또, 클래스를 선언하여 객체를 사용하는 방법조차 제대로 숙지하지 못하고 있었다. 문제풀이를 진행하면서 다양한 방법으로 구현해보는편이 좋다고 생각했다.

---
###### 8. 다음 학습 계획
- 백준 문제풀이
- 스프링 학습
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리