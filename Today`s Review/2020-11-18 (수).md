

###### 1. 학습 날짜

- 2020 - 11 - 18(화)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 뮤텍스

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- 뮤텍스를 이해하고 예제를 확인

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

### 보충2.4 :fallen_leaf:  뮤텍스 

1. Mutex lock는 특정 코드 영역의 쓰레드를 실행할 때 한번에 하나 이상의 쓰레드만 실행 가능하도록 하는 방법이다. (O / X)
  - 정답 : X , 한번에 하나의 쓰레드만 실행 가능하도록 하는 방법이다.

2. 아래의 코드 결과는 서술하시오.

```c
// exam2.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원, 1증가.
        sleep(1);
    }
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

// compile
// gcc exam2.c -o exam2
```
- 정답 : Thread1, 2 모두 g_count 쓰레드 자원을 공유하기 때문에 매번 exam2를 실행할 때 마다 이상한 값이 나온다.


3. 아래의 코드 결과를 서술하시오

```c
// exam3.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
// 뮤텍스 객체 선언
pthread_mutex_t mutex_lock;
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    
    
 
    pthread_mutex_lock(&mutex_lock);
 
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원
        sleep(1);
    }
 
    pthread_mutex_unlock(&mutex_lock);
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
    // 뮤텍스 객체 초기화, 기본 특성으로 초기화 했음
    pthread_mutex_init(&mutex_lock, NULL);
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

// compile
// gcc exam3.c -o exam3 -lpthread
```
- 정답 : Mutex Lock이 걸려서 Thread1이 먼저 실행된다면 Thread2는 1이 끝날 때 까지 임계영역에 들어가 수 없기 때문에 count 0 1 2를 출력하고 그 다음 Thread2의 count가 0 1 2 를 출력한다. 만약 Thread2가 먼저 실행된다면 앞에 설명한 것과 반대로 출력된다.

Mutex 코드 참고
https://bitsoul.tistory.com/172
</div>
</details>
<br><br>

---

###### 7. 학습 내용에 대한 개인적인 총평

- 뮤텍스 예제를 풀고 이를 이해함.

###### 8. 다음 학습 계획

- 세마포어