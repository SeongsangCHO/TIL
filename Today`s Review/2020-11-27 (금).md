

###### 1. 학습 날짜

- 2020 - 11- 27(금)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 컴퓨터구조

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- ALU

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# 1. ALU ?

- CPU 내부의 산술과 논리연산을 담당하는 하드웨어 모듈
- 산술연산장치. 논리연산장치, 비트들을 좌, 우측으로 이동시키는 시프트 레지스터, 상태레지스터, 보수기로 이루어져있음
- 이 요소들에 의해 처리될 데이터들은 레지스터 또는 기억장치로 부터 입력됨
- ALU는 연산의 결과에 따라 상태레지스터에 플래그값을 셋 하는데 그 플래그는 다음과 같음

## 1.1 ALU의 상태레지스터 플래그 값

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7eba35da-1035-41ae-8165-25a02ff8bb2d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7eba35da-1035-41ae-8165-25a02ff8bb2d/Untitled.png)

# 2. 정수의 표현

컴퓨터가 음수를 표현하는 방법은 다음 세가지

- 부호화-크기 표현
- 1의 보수 표현
- 2의 보수 표현

## 2.2 부호화-크기

표현하는 숫자의 비트가 n이면 맨 좌측 비트가 부호비트

맨 좌측비트는 (-1)의 1승인지, 0승인지 비트에 따라 갈림 0이면 +, 1이면 -

예시

- +9 ⇒ 0 0001001
- - 9 ⇒ 1 0001001

0의경우 + 0, - 0이 표현되므로 0을 검사하는 과정이 더 복잡해져서 보수표현이 등장

## 2.3 보수표현

- 1의 보수표현 : 모든 비트 반전
- 2의 보수표현 : 모든 비트 반전 후, 결과값에 1을더함.
- 2의보수가 더 많이 사용됨. 1의보수보다 표현할 수 있는 개수가 하나 더 많음.
  - 1의보수 : 127 ~ -127, 2의보수 : 127 ~ -128

# 3. 논리연산

AND, OR, XOR, NOT,  Selective-set, Selective-complement

- 선택적 세트 : 데이터 특정 비트를 1로 세트해주기 위함
  - OR연산을 통해 특정비트들을 1로 세트해줌
- 선택적 보수: 특정 비트를 보수화 1→0, 0→1 하기 위한 동작 XOR 연산 (다르면 1 같으면 0)
- 마스크연산 : 특정 비트를 0으로 리셋 AND연산
- 삽입연산 : 일부 비트들을 새로운 값으로 대체
  - 1단계, 마스크연산 - 모두 0으로 리셋
  - 2단계 OR연산
  - EX) 10010101의 상위 4비트를 1110으로 대체
    - 00001111과 마스킹연산(AND) - 00000101
    - 1110000과 삽입(OR)연산 - 11100101
- 비교연산:  A, B레지스터 내용을 비교하고 대응되는 비트값이 같으면 A레지스터 해당 비트를 0으로 세트 다르면 1로 세트 (XOR연산수행)

# 4. 시프트연산

논리적, 순환시프트연산을 사용하면 두 레지스터간 직렬 데이터 전송이 가능해짐.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e66a81e9-df73-4c37-88a2-74318df624fa/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e66a81e9-df73-4c37-88a2-74318df624fa/Untitled.png)

4번의 우측 시프트연산으로 A는 순환, B는 논리적으로 A의 값이 B레지스터로 전송할 수 있음.

## 4.1 논리적 시프트연산

논리적시프트연산은 비트들을 왼쪽, 혹은 오른쪽으로 한칸씩 이동시키는 것

- 좌측시프트 : 왼쪽으로 한칸씩 밀며 맨 우측 비트에 0이 들어옴 ⇒ 2를 곱한값
- 우측시프트: 모든 비트가 우측으로 한 칸씩 이동. 최상위 비트로 0이 들어옴, 맨 오른쪽 비트는 버림 ⇒ 2를 나눈값

## 4.2 순환 시프트

최상위, 하위비트를 버리지 않고 반대편의 끝 비트로 들어감

- 순환 좌측시프트 : 왼쪽으로 미는데 맨 좌측비트가 맨 우측비트로 다시 삽입됨

## 4.3 산술적 시프트

레지스터의 데이터가 부호를 가진 정수인 경우 부호비트를 고려해 수행.

시프트과정에서 부호 비트는 그대로 둠.

1110인 경우, 산술적 좌측 시프트를 수행하면

맨 상위 1은 그대로, 1 [1][1][0] ← 여기에서 0이 추가로 들어옴

3번수행시 1 0 0 0 이 됨

## 4.4 C(캐리)플래그를 포함한 시프트 연산

실제 CPU에서는 시프트 연산에 캐리 플래그가 포함됨

좌측 연산

C ← A4 A3 A2 A1 ← 0

으로 기존의 C는 버려지고 A4로 대체됨

순환연산도 가능하지만 우측 산술적 시프트연산에서는  C플래그에 값이 있고, 원래의 부호비트값과 다를 때 부호가 변경되므로 오버플로우 플래그를 세트해 그 사실을 알리거나 C 플래그가 레지스터에 들어오지 못하게 해서 부호비트를 그대로 유지할 수 있도록 해야함.

---

###### 7. 학습 내용에 대한 개인적인 총평

- ALU이 수행하는 산술연산과 논리연산에 대해서 학습하고 정리했음.

###### 8. 다음 학습 계획

- PS

