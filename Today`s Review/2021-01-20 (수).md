

###### 1. 학습 날짜

- 2021 - 01 - 20(수)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 필로소퍼

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- 필로소퍼 원 구현

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

https://jeonyeohun.github.io/2020/05/21/운영체제-식사하는-철학자-문제.html

- 철학자는 해당 시간안에 먹어야 살고, 먹고나선 특정 시간동안 자며, 바로 생각한다.
- 만약 모든 철학자가 왼쪽 포크를 집으면 교착상태가 발생하므로 모두 죽게된다. 따라서 짝수, 홀수번째 철학자가 집는 젓가락방향을 반대로하면 해당 교착상태가 발생하지 않고 번갈아서 음식을 먹을 수 있다.
- 젓가락 집는걸 기다리는 것을 뮤텍스를 사용하며 해당 젓가락이 사용가능할 때까지 젓가락을 집지못한 철학자는 이를 대기한다.
- 어떤 철학자가 먹는것을 마치고 젓가락을 내려놓으면 기다리고 있던 철학자가 해당 젓가락을 집는다.
- 먹기 시작한 순간에 먹은 시간이 기록되고 굶어죽는 시간은 현재시간에서 마지막으로 먹은 시간을 빼서 계산한다.
- 쓰레드는 데이터를 공유할 수 있고 해당 과제에서 수행되는 쓰레드는 필로소퍼당 2개의 쓰레드가 돌아간다.
- philo_life : 먹기위한 함수를 수행하고 죽었는지 체크하는 함수
- control_die : 굶은 시간을 체크하는 함수 ⇒ 죽었으면 다 죽임

# 프로그램이름

- philo_one

# 제출 폴더

- philo_one/
- 메이크파일 있어야함

# 인자

number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]

# 허락함수

- memset, malloc, free, write
- usleep, gettimeofday
  - usleep ⇒ 마이크로 초 후에 다음작업 수행
- pthread_create, pthread_detach, pthread_join
- pthread_mutex_init, pthread_mutex_destroy
- pthread_mutex_lock, pthread_mutex_unlock
- Libft 사용 못함.
- 뮤텍스로 구현

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
// 뮤텍스 객체 선언
pthread_mutex_t mutex_lock;
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    
    
 
    pthread_mutex_lock(&mutex_lock);
 
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원
        sleep(1);
    }
 
    pthread_mutex_unlock(&mutex_lock);
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
    // 뮤텍스 객체 초기화, 기본 특성으로 초기화 했음
    pthread_mutex_init(&mutex_lock, NULL);
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}
```



### **int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void \*arg)**

- 스레드의 생성을 위해 사용합니다.

**parameter**

- pthread_t *thread
  - 스레드가 성공적으로 생성되었을때 생성된 스레드를 식별하기 위해 사용하는 스레드 식별자
- const pthread_attr_t *attr
  - 스레드 특성을 지정
  - 기본 특성을 사용할 때는 NULL을 사용
- void *(*start_routine)(void *)
  - 분기시켜 실행할 스레드 함수
- void *arg
  - 스레드 함수의 인자 값

**return value**

성공적으로 생성될 경우 0을 리턴 실패한 경우 0이 아닌 에러코드 값을 리턴

### **int pthread_join(pthread_t th, void **thread_return)**

- 특정 스레드가 종료될 때까지 기다리며 스레드 자원을 해제함

**parameter**

- pthread_t th
  - join을 할 스레드 식별자
- void **thread_return
  - 스레드의 리턴 값
  - NULL이 아닐경우 해당 포인터로 스레드 리턴 값을 받아올 수 있음

**return value**

성공할 경우 th에 스레드 식별번호를 저장하고 0을 리턴 실패한 경우 0이 아닌 에러코드를 리턴

### **int pthread_detatch(pthread_t th)**

main스레드에서 pthread_create를 이용해 생성된 스레드를 분리함 식별번호 th인 스레드를 detach하는데, detach되었을 경우 해당 스레드가 종료될 경우 pthread_join을 호출하지 않더라도 즉시 모든 자원이 해제됨

**return value**

성공 시 0을 반환 실패 시 0이 아닌 값을 반환(에러 코드)

### **mutex**

Mutual Exclusion의 약자로 상호배제라고 합니다. 특정 스레드에서 단독으로 들어가야 되는 코드 영역에서 동기화를 위해 사용합니다.

이 문제에서는 하나의 포크를 두명의 철학자가 공유하게 되므로, 누군가 해당 포크를 사용하고 있을 때 다른 철학자가 접근하지 못하게 막는 용도로 사용합니다. 이때 사용중인 포크에 접근하여 mutex에 걸리게 되면 포크가 사용 가능한 상태가 될 때까지 스레드는 블럭됩니다.

### **int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr \*attr)**

mutex는 여러개의 스레드가 공유하는 데이터를 보호하기 위해 사용하는 도구 보호하고자 하는 데이터를 다루는 코드 영역을 한번에 하나의 스레드만 실행가능 하도록 하는 방법으로 공유되는 데이터를 보호함 이러한 영역을 critical section이라고 함

**parameter**

- pthread_mutex_t *mutex
  - 초기화 할 mutex 객체
- const pthread_mutex_attr *attr
  - mutex의 특성을 변경
  - 기본 값을 사용하기 위해서는 NULL사용

**return value**

성공시 0 반환 실패 시 -1을 반환하며 errno설정됨

### **int pthread_mutex_destroy(pthread_mutex_t \*mutex)**

인자로 주어지는 mutex객체 mutex를 제거하기 위해 사용됨 pthread_mutex_t *mutex는 pthread_mutex_init함수를 이용해 생성된 mutex객체 반드시 unlock상태여야 함

### **int pthread_mutex_lock(pthread_mutex_t \*mutex)**

critical section에 들어가기 위해 mutex lock을 요청 만약 이미 다른 스레드에서 mutex lock을 얻어서 사용하고 있다면 다른 스레드에서 mutex lock을 해제할 때까지 블럭됨

모든 작업을 마치고 mutex lock이 더 이상 필요 없다면 pthread_mutex_unlock을 호춯해서 mutex lock을 돌려줘야 함

⇒ 성공시 0 반환함. 잠금을 할 수 있을때 까지 기다리는 것

### **int pthread_mutex_unlock(pthread_mutex_t \*mutex)**

critical section에서의 모든 작업을 마치고 mutex lock을 돌려주기 위해 사용함

---

###### 7. 학습 내용에 대한 개인적인 총평

- 뮤텍스를 이용해 공유자원 접근에 대해 락을 걸어 교착상태를 피한다.

###### 8. 다음 학습 계획

- 필로소퍼