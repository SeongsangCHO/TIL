

###### 1. 학습 날짜

- 2020 - 12 - 03(목)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 컴퓨터구조

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- ALU에 대해 학습한다

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# 1. ALU ?

- CPU 내부의 산술과 논리연산을 담당하는 하드웨어 모듈
- 산술연산장치. 논리연산장치, 비트들을 좌, 우측으로 이동시키는 시프트 레지스터, 상태레지스터, 보수기로 이루어져있음
- 이 요소들에 의해 처리될 데이터들은 레지스터 또는 기억장치로 부터 입력됨
- ALU는 연산의 결과에 따라 상태레지스터에 플래그값을 셋 하는데 그 플래그는 다음과 같음

## 1.1 ALU의 상태레지스터 플래그 값

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7eba35da-1035-41ae-8165-25a02ff8bb2d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7eba35da-1035-41ae-8165-25a02ff8bb2d/Untitled.png)

# 2. 정수의 표현

컴퓨터가 음수를 표현하는 방법은 다음 세가지

- 부호화-크기 표현
- 1의 보수 표현
- 2의 보수 표현

## 2.2 부호화-크기

표현하는 숫자의 비트가 n이면 맨 좌측 비트가 부호비트

맨 좌측비트는 (-1)의 1승인지, 0승인지 비트에 따라 갈림 0이면 +, 1이면 -

예시

- +9 ⇒ 0 0001001
- - 9 ⇒ 1 0001001

0의경우 + 0, - 0이 표현되므로 0을 검사하는 과정이 더 복잡해져서 보수표현이 등장

+, - 연산시 부호와 크기비트를 따로 처리해주어야함

## 2.3 보수표현

- 1의 보수표현 : 모든 비트 반전
- 2의 보수표현 : 모든 비트 반전 후, 결과값에 1을더함.
- 2의보수가 더 많이 사용됨. 1의보수보다 표현할 수 있는 개수가 하나 더 많음.
  - 1의보수 : 127 ~ -127, 2의보수 : 127 ~ -128

# 3. 논리연산

AND, OR, XOR, NOT,  Selective-set, Selective-complement

- 선택적 세트 : 데이터 특정 비트를 1로 세트해주기 위함
  - OR연산을 통해 특정비트들을 1로 세트해줌
- 선택적 보수: 특정 비트를 보수화 1→0, 0→1 하기 위한 동작 XOR 연산 (다르면 1 같으면 0)
- 마스크연산 : 특정 비트를 0으로 리셋 AND연산
- 삽입연산 : 일부 비트들을 새로운 값으로 대체
  - 1단계, 마스크연산 - 모두 0으로 리셋
  - 2단계 OR연산
  - EX) 10010101의 상위 4비트를 1110으로 대체
    - 00001111과 마스킹연산(AND) - 00000101
    - 1110000과 삽입(OR)연산 - 11100101
- 비교연산:  A, B레지스터 내용을 비교하고 대응되는 비트값이 같으면 A레지스터 해당 비트를 0으로 세트 다르면 1로 세트 (XOR연산수행)

# 4. 시프트연산

논리적, 순환시프트연산을 사용하면 두 레지스터간 직렬 데이터 전송이 가능해짐.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e66a81e9-df73-4c37-88a2-74318df624fa/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e66a81e9-df73-4c37-88a2-74318df624fa/Untitled.png)

4번의 우측 시프트연산으로 A는 순환, B는 논리적으로 A의 값이 B레지스터로 전송할 수 있음.

## 4.1 논리적 시프트연산

논리적시프트연산은 비트들을 왼쪽, 혹은 오른쪽으로 한칸씩 이동시키는 것

- 좌측시프트 : 왼쪽으로 한칸씩 밀며 맨 우측 비트에 0이 들어옴 ⇒ 2를 곱한값
- 우측시프트: 모든 비트가 우측으로 한 칸씩 이동. 최상위 비트로 0이 들어옴, 맨 오른쪽 비트는 버림 ⇒ 2를 나눈값

## 4.2 순환 시프트

최상위, 하위비트를 버리지 않고 반대편의 끝 비트로 들어감

- 순환 좌측시프트 : 왼쪽으로 미는데 맨 좌측비트가 맨 우측비트로 다시 삽입됨

## 4.3 산술적 시프트

레지스터의 데이터가 부호를 가진 정수인 경우 부호비트를 고려해 수행.

시프트과정에서 부호 비트는 그대로 둠.

1110인 경우, 산술적 좌측 시프트를 수행하면

맨 상위 1은 그대로, 1 [1][1][0] ← 여기에서 0이 추가로 들어옴

3번수행시 1 0 0 0 이 됨

## 4.4 C(캐리)플래그를 포함한 시프트 연산

실제 CPU에서는 시프트 연산에 캐리 플래그가 포함됨

좌측 연산

C ← A4 A3 A2 A1 ← 0

으로 기존의 C는 버려지고 A4로 대체됨

순환연산도 가능하지만 우측 산술적 시프트연산에서는  C플래그에 값이 있고, 원래의 부호비트값과 다를 때 부호가 변경되므로 오버플로우 플래그를 세트해 그 사실을 알리거나 C 플래그가 레지스터에 들어오지 못하게 해서 부호비트를 그대로 유지할 수 있도록 해야함.

## 5 정수의 산술연산

### 5.1 덧셈

데이터 비트 수 만큼 전가산기들로 구성되는 **병렬 가산기**는

2의 보수로 표현된 수들 간의 덧셈은, 더하고 올림수 발생시 버린다.

n비트로 표현할 수 없는 숫자가 덧셈을 통해 생긴다면 이를 오버플로우라 하며

올림수의 Cn, Cn-1 비트 와 XOR연산을 통해 오버플로우를 검출할 수 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/42fab8c1-c87f-46d1-9581-fead41e7c6fb/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/42fab8c1-c87f-46d1-9581-fead41e7c6fb/Untitled.png)

C4는 0, C3은 1이므로 0 , 1 XOR연산으로 오버플로우가 됐다는 것을 알 수 있다.

### 5.2 뺄셈

A로부터 B를 뺴려면 B를 음수화하고 둘을 더하면 된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d8d7e3c-a133-4f60-9326-57b621ecebd5/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d8d7e3c-a133-4f60-9326-57b621ecebd5/Untitled.png)

뺄셈에서의 오버플로우도 덧셈과같은 검출회로를 통해 검출한다.

### 5.3 곱셈

부호없는 정수들을 곱셈

2의 보수로 표현된 수들의 곱셈

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5891971f-e406-4ff0-bf37-d52793e6a8b5/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5891971f-e406-4ff0-bf37-d52793e6a8b5/Untitled.png)

### 5.4 나눗셈

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/288117c4-c1e5-42d4-a508-890e12091aeb/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/288117c4-c1e5-42d4-a508-890e12091aeb/Untitled.png)

## 7. 부동소수점 수의 표현

수를 표현하기 위해 소수점의 위치를 지수로 표시하는 것을 부동소수점 표현이라고 한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/91bd1e2a-8714-4ac2-8a40-1dd9ddb9ff57/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/91bd1e2a-8714-4ac2-8a40-1dd9ddb9ff57/Untitled.png)

M은 가수, B는 기수, E는 지수를 나타낸다.

2.74 * 10^14 인 경우 가수는 2.74, 지수는 +14 가수는 10이다.

컴퓨터에서는 2진수체계이므로 2진부동소수점 수가 되는데 위와 다른점은 B. 기수가 2인 것만 다르다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8aebde08-88b2-44ea-8df7-779abb2acc44/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8aebde08-88b2-44ea-8df7-779abb2acc44/Untitled.png)

가수가 정밀도를 결정하고, 지수가 표현가능한 수의 범위를 결정하는데. 지수필드의 비트수가 많아지면 표현범위가 증가한다.

부동소수점은 한 수에 대해 여러 표현이 존재할 수 있다.

0.11 * 2^5 == 11.01 * 2^3 ..등등이 있으므로 한가지 표준 형식으로 정해 사용한다.

### 정규화된 표현

소수점 우측의 첫 비트를 1이 되도록 지수를 조정해 표현

0.1101 * 2^5 ⇒로 나타낸다. 소수점 우측 비트가 반드시 1이되도록하는 것.

### 7.1 부동소수점의 덧셈 뺄셈

1. 두 소수점 위치를 일치
2. 기수들 간에 더하기 혹은 빼기
3. 결과 정규화

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c9ca910-fbb3-4fe4-9c11-a58557f63fc7/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c9ca910-fbb3-4fe4-9c11-a58557f63fc7/Untitled.png)

### 7.2 곱셉과 나눗셈

1. 가수들을 곱한다. / 가수 나눈다
2. 지수들을 더한다 / 지수 뺀다.
3. 결과 정규화

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd136335-b9b0-494f-8db0-cb17b7e6185e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd136335-b9b0-494f-8db0-cb17b7e6185e/Untitled.png)

해당 연산에서 문제가 발생할 수 있음

- 지수 오버 플로우 : 양의 지수값이 최대 지수값을 초과하는 경우 결과를 +무한대, -무한대로 세트
- 지수 언더플로우 : 음의 지수값이 최대 지수값 초과하는 경우 결과 0으로 세트
- 가수 오버플로우 : 가수 소수점위치 조정하기 위해 우측 시프트 수행하는 과정에서 비트들이 가수 필드 우측편으로 넘치는 경우 , 반올림 혹은 절삭함
- 가수 언더플로우 : 같은 부호를 가진 두 가수를 덧셈했을 때 올림수 발생(범위 초과) 가수를 우측 쉬프트 + 지수를 증가시켜 정규화한다.

---

###### 7. 학습 내용에 대한 개인적인 총평

- ALU에 대해서 자세히 알아보았다.

###### 8. 다음 학습 계획

- JS