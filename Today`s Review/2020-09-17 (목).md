

###### 1. 학습 날짜

- 2020 - 09 - 17(목)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- nodeJS 웹 크롤링

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- puppeteer의 사용법과 headless, Promise.all을 사용하고 이해한다.

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

## 노드 웹 크롤링  Ch02

<br>

[공식문서](github.com/GoogleChrome/puppeteer)

### 2.1 puppeteer 시작하기



#### 퍼펫티어를 사용하는 이유

- 1초에 10번씩 클릭하면 안되므로 사람인척 해야함.

- `userAgent` : 내 브라우저가 크롬인지, 파폭인지 나타내는 문자열 접속할 때 bot은 `bot`이라고 티가남. 따라서 정상적인 브라우저로 속이기 위해서

<br>

#### 설치

- `npm i puppeteer`
- 크롬 브라우저의 기반인 `Chromium` 브라우저를 같이 받으므로 서버용량이 1기가정도 여유가 되어야함



#### 구현 예제

- 페이지 열고, 기다리고하는 작업들은 비동기작업이라서 퍼펫티어 명령어는 앞에 `await`를 붙이는 비동기 처리를 해야한다.

- ```javascript
  const crawler = async() => {
      try{
      const browse = await puppeteer.launch({ headless: false});
      const page = await brower.newPage();
      await page.goto('secho.com'); //페이지이동
      await page.waitFor(3000); //로딩 후 3초뒤 종료시키기
      await page.close();// 페이지 닫기
      await browser.close(); // 브라우저 닫기   
      } catch(e){
          console.error(e);
      }
  }
  ```

   



---

<br>

### 2.2 headless 옵션 이해

위의 예제에서 `headless` 옵션을 사용했다

#### headless

- 화면을 사용자가 볼 수 있는지에 대한 유무를 정함
- `true`: 볼 수없음
- `false`: 볼 수있음
- 그럼 화면이 필요없는 브라우저가 있나?
  - 크롤러는 서버에게 명령을 하는데 서버는 주로 `CLI`형태로 사용하므로 배포할 때는 `true`를 적용
  - `headless: process.env.NODE_ENV === 'production'` : 환경변수 사용으로 배포일 때만 적용하도록 사용을 많이함

<br>

#### Promise.all

- 동시에 , 순서가 보장되지 않을 때 사용 -> 속도가 빠름
- 아래 예제처럼 하나씩 페이지를 동작할 때 기다려야하므로 시간낭비/

```javascript
await page.goto(url);
await page2.goto(url);
await page3.goto(url);
```

<br>

- `Promise.all`을 사용해서 동시에 진행되도록 할 수 있음.

```javascript
const [page, page2, page3] = await Promise.all([
    browser.newPage(),
    browser.newPage(),
    browser.newPage()
]);
await Promise.all([
    await page.goto(url);
    await page2.goto(url);
    await page3.goto(url);
]);
```



---

<br>

### 2.3 첫 puppeteer 크롤링

- 실제 크롤링 해보기

```javascript
await Promise.all(records.map(async (r,i) => {
	const page = await browser.newPage();
	await page.goto(r[1]);
	const scoreEl = await page.$('.score.score_left .star_score');// $가 태그찾는 메소드
    if(scoreEl){//태그를 제대로 찾았는지 확인해야함
    	const text = await page.evaluate(tag => tag.textContent, scoreEl); // scoreEl 태그에서 tag.textContent를 반환한다.  
    }
}));
```

- 크롤링을 차단하는 페이지는 `page.waitFor(ms)`을 조금씩 늘려보면서 사용해보자

- `evaluate` : JS코드를 사용할 수 있게 해주는 함수

  - ```javascript
       	await page.evaluate(( { magicId, magicPw } ) => {
           	document.getElementById( "loginId" ).value = magicId;
           	document.getElementById( "loginPw" ).value = magicPw;
    // document.getElementsByClassName( "btn_login" ).disabled = false;
    	}, { magicId, magicPw } );
    ```

    [출처](http://magic.wickedmiso.com/177)

#### UnhandledPromiseRejectionWaring 에러가 발생했을 때

- async 함수 내부에 try catch로 감싸 에러를 잡아야한다.
- async함수당 try catch를 최소 하나이상씩 넣어주어야한다.

---

###### 7. 학습 내용에 대한 개인적인 총평

- `Promise.all`, `headless`의 사용시기에 대해 알 수 있었다.

###### 8. 다음 학습 계획

- 자료구조 Tree