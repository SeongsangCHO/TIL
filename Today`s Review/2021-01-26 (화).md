###### 1. 학습 날짜

- 2021 - 01 - 26(화)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- cpp01

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- cpp01 구현

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

https://www.francescmm.com/orthodox-canonical-class-form/

캐노니컬폼 ;

Memory allocation, References, Pointers to members,File streams

# Ex00

- ex00/Pony.cpp, Pony.hpp, main.cpp 3개 제출
- **스택(Stack)** 공간은 지역변수와 매개변수 등이 할당되는 임시적인 영역입니다.
- **힙(Heap)** 공간은 동적으로 메모리를 할당하는 곳이며 생성 중 크기를 결정합니다.

출처:

https://yeolco.tistory.com/117

[열코의 프로그래밍 일기]

- Pony클래스 만들어라
  - 2개의 함수, `ponyOnTheHeap, ponyOnTheStack` 함수 생성하고, 뭔가를 하게 만들어라..
  - 하나는 힙에 할당되어야하고 하나는 스택에 할당해야한다.
    - 하나는 동적할당, 하나는 그냥 고정할당으로 하는듯.
  - 의도 동작대로 작동하는 것을 증명할 수 있도록 메인에 작성해라
  - 포니객체가 더이상 없을 때 행동하지 않도록 메인에도 증명해 놓아야함.
  - ?

# EX01

- ex01/ex01.cpp 만 제출
- 포함된 메모리 누수를 수정하고 다음 함수를 입력메모리 할당, 할당 해제작업을 해야함.

```jsx
void memoryLeak()
{
std::string* panther = new std::string("String panther");
std::cout << *panther << std::endl;
}
```

# Ex02

- ex02/Zombie.cpp, Zombie.hpp, ZombieEvent.cpp, ZombieEvent.hpp main.cpp 제출
- 타입은 ZombieEvent의 setZombieType으로 지정하고 이름은 randomChump로 랜덤하게 만들어서 이름과 타입을 갖는 좀비객체를 만드는데 객체가 생성될 때 그르르르르하게 만들라는 거군.
- `Announce()` 멤버함수 작성해라
  - <name (type)> Braiiiinssssss...
  - 좀비 이름과 유형
- ZombieEvent 클래스에는 `setZombieType` 함수를 작성해야한다.
- `Zombie *newZombie(std::string name)`은 선택한 유형으로 좀비를 만들고 이름을 지정하여 반환한다.
- `randomChump` 함수를 만들어서 임의의 이름을 가진 좀비를 생성하고 스스로 알리게 한다.
  - 생성자할 때 말하라는거 같은데
- 어떤 랜덤방법으로 선택하든, 진정한 랜덤 또는 이름 풀에서 무작위 선택까지 OK
- 메인에는 새로 생성된 좀비가 자신을 알리도록 작성해야함
- 좀비는 적절한 시간에 파괴되어야함(더 이상 필요하지 않을 때) 또한 적절한 방법으로 할당해야함.
- 어떨땐 스택, 다른 땐 힙이 더 나은 선택일 수 있다.
- 뉴 좀비로 먼저 만들고 복사생성자로 랜덤청크해서 새로 생성하라는 뜻인가보네

# Ex03

- ex03/Zombie.cpp, Zombie.hpp, ZombieHorde.cpp, ZombieHorde.hpp , main.cpp
- 좀비 클래스를 재 사용하고 ZombieHorde클래스를 만든다
- 이 클래스는 정수 N을 사용하는 생성자를 갖는다.
- 생성시 임의의 이름으로 N Zombie객체를 할당하고 저장한다.
- 그런다음 각 Zombie객체에 대해 `Announce()`를 호출하는 `Announce()`를 갖게된다;;
- 모든 좀비 객체를 단일 할당으로 할당하고 `ZomibeHorde`가 파괴되면 해제해야한다.
- 테스트를 메인에 제공하라

# Ex04

- ex04/ex04.cpp
- "HI THIS IS BRAIN", 포인터 및 참조를 포함하는 문자열을 작성하는 프로그램을 작성하십시오. 그런 다음 포인터를 사용하여 표시하고 마지막으로 참조를 사용하여 표시합니다. 그게 다야, 속임수는 없습니다.
- &참조연산자는 새로운 변수타입
  - 참조형은 참조하는 값과 동일하게 작동함.

```jsx
int value = 5;
int& ref = value; => ref == value => 값과 같은 메모리를 참조한다.
// 참조를 선언할 때 초기화해야한다. 최초 선언시에만 초기화 가능함.
//참조하기 위해 포인터로 만들 수 있음
int *ptr = &value; => 똑같이 참조함.

value = 6;
ref = 7;

cout<< value => 7
++ref;
cout << value == 8
```

# Ex05

this memory Address to Hex

stringstream은, 주어진 문자열에서 필요한 정보를 빼낼 때 유용하게 사용된다.

출처:

https://word.tistory.com/24

https://stackoverflow.com/questions/8737019/whats-the-size-of-hex-value-of-some-memory-address-converted-to-int-or-other-ty

- ex05/Brain.cpp Brain.hpp Human.cpp Human.hpp main.cpp
- 두뇌에 적합하다고 생각하는 모든 것으로 Brain 클래스를 만드십시오.
- 16 진수로 메모리에 두뇌의 주소를 포함하는 문자열을 반환하는 식별 () 함수가 있습니다.
- 0x로 시작하는 형식 (예 : "0x194F87EA"). 그런 다음 동일한 수명을 가진 일정한 Brain 속성을 갖는 Human 클래스를 만듭니다.
- Brain의 식별 () 함수를 호출하고 결과를 반환하는 식별 () 함수가 있습니다.
- 이제이 코드가 두 개의 동일한 주소를 컴파일하고 표시하도록 만듭니다.

```jsx
int main()
{
Human bob;
std::cout << bob.identify() << std::endl;
std::cout << bob.getBrain().identify() << std::endl;
}
```

- 이 코드는 메인으로 제출되어야하며, 작동하도록하기 위해 Human 또는 Brain 클래스에 추가하는 모든 것은 정당화되어야합니다 ( "어, 그래, 잘 될 때까지 만져 봤어.")

# Ex06

- ex06/ Weapon.cpp Weapon.hpp HumanA.cpp HumanA.hpp HumanB.cpp HumanB.hpp main.cpp
- Weapon클래스를 만들어라, type string, 이건 const참조를 반환하는 getType을 작성
- 또한 setType도 작성
- 이제 HumanA, HumanB 클래스를 작성하고 둘 다 Weapon, name, attack()함수를 갖는다
- NAME attacks with his WEAPON_TYPE

```jsx
int main()
{
	{
		Weapon club = Weapon("crude spiked club");
		HumanA bob("Bob", club); //
//선언되는 순간에 누굴 참조할지 알아야하는 참조자를 사용해야한다.
//생성될 때 private 객체에 참조해야함.
		bob.attack();
		club.setType("some other type of club");
		bob.attack();
	}
	{
		Weapon club = Weapon("crude spiked club");
		HumanB jim("Jim"); // 언제든지 접근할 수 있는 포인터를 사용
		jim.setWeapon(club);
		jim.attack();
		club.setType("some other type of club");
		jim.attack();
	}
}
```

어떤 경우에 무기를 포인터로 저장하는 것이 적절합니까? 참고로? 왜? 질문에 비추어 볼 때 최선의 선택입니까? 이것이 당신이해야 할 질문 이 연습을 시작하기 전에 스스로에게 물어보십시오.

# 포인터 참조자 차이

- # 공통점 : 포인터와 참조자는 다른 객체(변수)를 간접적으로 참조하는 역할을 한다.즉, 원본 대상을 포인터와 참조자를 이용하여 대신 이용할 수 있도록 한다는 겁니다. 그럼 같은 역할을 하는게 왜 2개나 있을까요? 물론 사용하는 용도에 차이점이 있기때문에 그렇습니다. 그럼 어떤 차이점이 있는지 살펴봅시다

- # 차이점 : 포인터는 널 값을 가질 수 있지만 참조자는 널 값을 가질 수 없다. 즉, 널 참조자(null reference)는 없다.위의 말은 포인터는 자신이 참조하는 대상을 원하는 아무 때나 참조할 수 있지만 참조자는 자신이 선언되는 순간에 참조하려는 대상을 알고 있어야만 한다는 뜻입니다. 코드로 살펴보면 다음과 같습니다.

int * pNum = NULL; // 통과.int & rNum = NULL; // 에러.int num = 100;int & rNum = num  // 통과. (참조자는 선언 시 반드시 초기화를 해야한다.)

https://whitesnake.uzoo.in/29

# Ex07

https://mynotepad.tistory.com/134

replace(어느 부분부터, 얼마나, 무엇으로 치환할지)

str.replace(9, 5, str2); ⇒ 인덱스 9부터  str의 5글자를 str2의 글자로 변경한다.

내가 필요한건, readLine.replace( 바꿀 문자열의 시작인덱스, 바꿔질 문자의 길이, 바꿀 문자열)로 하면됨

시작인덱스는 find로 찾음 ⇒ getLine.find(바꿀 문자열)

- ex07/Makefile, and whatever else you need

파일 이름과 두 개의 문자열을 사용하는 replace라는 프로그램을 만드십시오. 비어 있지 않은 s1과 s2라고합시다. s1의 모든 항목을 s2로 바꾼 후 파일을 열고 내용을 FILENAME.replace에 기록합니다. 물론 오류를 최대한 처리하고 C 파일 조작 기능을 사용하지 않을 것입니다. 그 이유는 부정 행위이고 부정 행위는 나쁘기 때문입니다. 프로그램이 작동하는 것을 보여주기 위해 몇 가지 테스트 파일을 제출합니다.

# 파일 열기

https://blockdmask.tistory.com/322

Opening a file is done in the same way for all 3 file streams (`ifstream`, `ofstream`, and `fstream`).

You can open the file directly in the constructor:

```
std::ifstream ifs("foo.txt");  // ifstream: Opens file "foo.txt" for reading only.

std::ofstream ofs("foo.txt");  // ofstream: Opens file "foo.txt" for writing only.

std::fstream iofs("foo.txt");  // fstream:  Opens file "foo.txt" for reading and writing.
```

**char 하나씩 읽으면 감질맛나지, 한줄씩 읽어와볼까? getline 함수**

함수원형 : **istream& getline(char\* str, streamsize len);**

함수설명 : 한줄씩 문자열을 읽어서 str에 저장해주는 함수입니다.

한줄의 기준은 '\n' 문자열의 끝을 알리는 개행 문자가 올때 까지, 혹은 파일의 끝을 알리는 EOF를 만날때 까지 입니다

*위 ifstream::getline() 함수를 사용할때 주의

할점은 문자열을 받아오는 형태가 char* 타입이기 때문에 string 타입으로 바로 받을 수 없다는 특징이 있습니다.

https://blockdmask.tistory.com/322

**그래서 파일의 끝이 어디라고? eof 함수**

함수원형 : bool eof() const;

함수설명 : 파일의 끝이 나오면 true를 반환하고 아니면 false를 반환합니다.

파일을 읽을때 커서가 움직이게 되는데 그 커서가 getline, get 함수를 돌게되면 쭉쭉쭉 뒤로 가게 됩니다.

# 파일 쓰기

**[C++] 파일에 쓰기 ofstream**

ofstream을 풀어쓰면 output file stream 입니다.

output = 출력, 생산량

"프로그램에 있는 어떤 것들을 파일에 출력한다." 이런 풀이가 됩니다.

**프로그램의 출력을 파일에 할 수 있게 돕는 클래스** 입니다.

```jsx
>> 파일에 쓰기 간단 예제

std::ofstream writeFile;            //쓸 목적의 파일 선언

writeFile.open("words.txt");    //파일 열기

char arr[11] = "BlockDMask";        //파일에 쓸 문자열

if(writeFile.is_open())    //파일이 열렸는지 확인

{

writeFile.write(arr, 10);    //파일에 문자열 쓰기

}

writeFile.close();    //파일 닫기

출처: <https://blockdmask.tistory.com/322> [개발자 지망생]
#include<iostream>
#include<fstream>
#include<string>
using namespace std;
 
int main(void)
{
    ofstream writeFile;
    writeFile.open("test.txt");    //파일 열기(파일이 없으면 만들어짐)
 
    //1. char[] 문자열 쓰기
    char arr[11] = "BlockDMask";    //"BlockDMask\\0"
    writeFile.write(arr, 10);
 
    //2. string 문자열 쓰기
    string str = " is handsome.";
    writeFile.write(str.c_str(), str.size());
    
    //str.c_str() : C++ string -> const char* 으로 변환해주는 함수
 
    writeFile.close();    //꼭 닫아주기
    return 0;
}

출처: <https://blockdmask.tistory.com/322> [개발자 지망생]
```

---

###### 7. 학습 내용에 대한 개인적인 총평

- cpp01 구현. 파일 입출력 구현

###### 8. 다음 학습 계획

- cpp 02