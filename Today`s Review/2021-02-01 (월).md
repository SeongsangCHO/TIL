

###### 1. 학습 날짜

- 2021 - 02 - 01(월)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- cpp04

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- cpp04

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# Virtual

- 함수에 붙일 수 있고 이를 통해 오버리이딩이 가능해진다.

- 상속에서 오버라이딩하기 위해서 가상함수여야한다.

- 부모를 상속받은 하위클래스에서 부모클래스에 있는 함수를 선택하지 않고 오버라이딩된 자기 함수를 호출하기 위해서 필요한 키워드

  - 부모, 자식 클래스 함수에 각각 virtual을 붙이면 해당 클래스에서 오버라이딩된 함수가 호출됨. ⇒ 자식에 없으면 부모클래스 거 호출하겟찌.
  - virtual을 붙이지 않고 오버라이딩해서 호출하면 호출되는 함수의 주소는 전부 동일하다 ( 조상 클래스 함수의 주소를 따름 )
  - virtual을 붙여도 주소는 같은데, 이 가상함수를 소유한 클래스는 가상함수테이블을 가리키는 가상함수 포인터를 갖게된다. 이를 통해 호출할 때 함수의 주소를 받을 수 있어서 각 클래스에 오버라이딩된 함수를 호출하게 되는 것.
  - 그런데 다형성 이용을 위해 부모 클래스의 포인터로부터 자식 클래스를 호출할 때, 가상 함수로 정의되지 않은 자식 클래스의 오버라이딩된 함수를 호출하면 부모 클래스의 멤버 함수가 호출된다. 소멸자도 자식 클래스에서 오버라이딩된 함수라고 볼 수 있기 때문에 만약 부모 포인터로 객체를 삭제하면 부모 클래스의 소멸자가 호출된다.
  - 따라서 소멸자를 가상 함수로 선언하지 않으면 이 경우 자식 클래스의 소멸자는 결코 호출되지 않는다. 가상 함수 키워드 virtual이 사용되었다면 이것은 자식 클래스에서 재정의될 수 있음을 명시하기 때문에 포인터의 종류에 상관없이 항상 자식 클래스의 메서드가 호출된다. 즉, 자식 클래스의 소멸자가 호출되고 나서 부모 클래스의 소멸자가 호출된다.

  ⇒ 소멸자에도 virtual 키워드를 붙여주자. 부모클래스에서.

# 다형성 구현

- 상속받을 때 같은 이름을 갖고 다른 기능을 하는 것
- 같은 1만원이라도 100원 100개, 천원 열장 만원 한장 등 같은 것을 표현하는데 여러가지 방법이 있을 수 있음. 이를 다형성이라함
- 상속해주는 클래스는 선언부만있고 구현부는 없는데 이는 상속받은 클래스에서 구현할 것임. 구현부가 없는 것은 추상클래스라고 부르고 하위클래스에서 구현되어 사용된다.
- https://pacs.tistory.com/entry/C-상속과-다형성-Inheritance-Polymorphism

## CRTP(Curiously recurring template pattern)

CRTP는 클래스 X가 X 자신을 템플릿 인자로 사용하여 클래스 템플릿 인스턴스화로부터 파생되게 하는 C++ 표현(Idiom, 관용구 )이다. 이 표현 이름은 1995년에 Jim Coplien에 의해 만들어 졌다.

### 1. 일반적 형식

```jsx
// The Curiously Recurring Template Pattern (CRTP)
template<class T>
class Base
{
    // methods within Base can use template to access members of Derived
};
class Derived : public Base<Derived>
{
    // ...
};
```

# ex00

- 다형성은 마법사, 마법사 및 기타 charlatans 시대로 거슬러 올라가는 고대 전통입니다.
- 우리가 먼저 생각했다고 생각하게 만들 수도 있지만 그건 거짓말입니다!
- 우리 친구 Robert, 장엄한 마술사에 관심을 가져 보자.
- 로버트는 흥미로운 취미를 가지고 있습니다. 손을 얹을 수있는 모든 것을 양, 조랑말, 수달 및 기타 불가능한 것들에 변형시키는 것입니다 (주변을 본 적이 있습니까 ...?).
- 이름과 제목이있는 Sorcerer 클래스를 만드는 것으로 시작하겠습니다. 마법사 이름과 제목을 매개 변수로 사용하는 생성자가 있습니다 (이 순서대로).
- 이 클래스는 매개 변수 없이는 인스턴스화 될 수 없습니다 (말이되지 않습니다! 이름도없고 직함도없는 마법사를 상상해보세요 ... 불쌍한 녀석, 그는 선술집의 웽 치를 자랑 할 수 없었습니다 ...). 하지만 여전히
- 의 양식을 사용해야합니다. 다시 말하지만, 어떤 형태의 트릭이 관련되어 있습니다. 우리는 그렇게 변덕 스럽습니다.

# ex01

### AWeapon class

- 무기에는 이름, 명중시 가해지는 데미지 포인트 수, AP (액션 포인트)의 사격 비용이 있습니다.
- 무기는 attack()하면 특정 소리와 조명 효과를 생성합니다.
- 이것은 상속 클래스로 연기됩니다.
- 그런 다음 구체적인 클래스 PlasmaRifle 및 PowerFist를 구현할 수 있습니다. 그 특징은 다음과 같습니다.
  - Rifle, Fist는 웨폰클래스를 상속받고 각자 이름, 데미지, apcost를 상속받아 값을 재정의함.
  - 근데 멤버변수를 상속받아야하는데 웨폰클래스는 왜 프라이빗임;?

```jsx
Character* me = new Character("me"); // 그냥 생성자?
std::cout << *me; // << 오버로딩
Enemy* b = new RadScorpion(); // 대입연산자 오버로딩
AWeapon* pr = new PlasmaRifle(); // 대입연산자 오버로딩
AWeapon* pf = new PowerFist();

me->equip(pr); // Character 멤버함수 equip(AWeapon*);
=> Character
```

⇒ 대입연산자 오버로딩해서 pr에 대입되는 &org의 데이터를 복사함.

하 요구사항 빡치네 ㄹㅇ;

# ex02

ISpaceMarine의 인터페이스(틀)을 상속받는 터미네이터와 택티컬마린객체를 생성한다.

함수는 - battleCry, 범위, 개인공격이 있다.

ISquad를 상속받는 Squad클래스를 작성한다.

- 마린의 수를 리턴하는 getCount
- 특정 번호 마린을 리턴하는 getUnit
- 분대의 끝에 마린을 추가하는 push → linkedList로 구현
- 대입연산자는 기존 리스트를 모두 초기화시키고, deep_cpy으로
  - squad::node(구조체)를 반환하는데 해당 내용은 lst_deep_cpy의 재귀호출로(반환 - 구조체) node→next는 계속 다음을 가리키고 ISpaceMarine은 해당 노드에 해당하는 객체 자신을 복제해 계속해서 대입.

# 인터페이스 작성

### ISquad.hpp

- `getCount` : 유닛 수 반환
- `getUnit(N)` : N번째 인원 포인터 반환. 초기는 0. 널포인터는 out of bounds index
- `push` : 분대 끝에 XXX 유닛을 추가합니다. 작업 후 스쿼드의 유닛 수를 반환합니다 (null 유닛 또는 이미 스쿼드에있는 유닛을 추가하는 것은 당연히 말이되지 않습니다 ..

결국 우리가 요청하는 분대는 우리가 당신의 군대를 올바르게 구성하는 데 사용할 스페이스 마린의 간단한 컨테이너입니다. 카피 구성 또는 스쿼드 할당시 카피는 깊어 야합니다. 배정시 이전에 분대에 유닛이 있었다면 교체하기 전에 파괴해야합니다. 모든 단위가 new로 생성 될 것이라고 가정 할 수 있습니다. 분대가 파괴되면 내부 유닛도 순서대로 파괴됩니다. TacticalMarine의 경우 구현할 인터페이스 (ISpaceMarine.hpp 포함)는 다음과 같습니다.

### ISpaceMarine

```jsx
class ISpaceMarine
{
public:
	virtual ~ISpaceMarine() {}
	virtual ISpaceMarine* clone() const = 0;
	virtual void battleCry() const = 0;
	virtual void rangedAttack() const = 0;
	virtual void meleeAttack() const = 0;
};
```

- clone() : 현재 객체의 복사값 리턴
- 생성자 메시지 : Tactical Marine ready for battle!
- battleCry() 출력 메시지 : For the holy PLOT!
- rangedAttack 출력 메시지 : * attacks with a bolter *
- meleeAttack() 출력 메시지 : * attacks with a chainsword *
- 소멸자 메시지 : Aaargh...

같은 방식으로 `AssaultTerminator` 도 작성

- Birth : * teleports from space *
- battleCry() : This code is unclean. PURIFY IT!
- rangedAttack() :  * does nothing *
- meleeAttack : * attacks with chainfists *
- Death : I'll be back...

다음과 같은  예제. 니 생각대로 추가해라

```jsx
int main()
{
	ISpaceMarine* bob = new TacticalMarine;
	ISpaceMarine* jim = new AssaultTerminator;
	ISquad* vlc = new Squad;
	vlc->push(bob);
	vlc->push(jim);
	for (int i = 0; i < vlc->getCount(); ++i)
	{
	ISpaceMarine* cur = vlc->getUnit(i);
	cur->battleCry();
	cur->rangedAttack();
	cur->meleeAttack();
	}
	delete vlc;
	return 0;
}

$> clang++ -W -Wall -Werror *.cpp
$> ./a.out | cat -e
Tactical Marine ready for battle!$
* teleports from space *$
For the holy PLOT!$
* attacks with a bolter *$
* attacks with a chainsword *$
This code is unclean. PURIFY IT!$
* does nothing *$
* attacks with chainfists *$
Aaargh...$
I'll be back...$
```

# ex03

AMateria ⇒ 추상클래스

이 추상클래스를 인스턴스화하는 ICE, CURE클래스

- A Materia의 XP는 0부터 시작하고 use()를 호출할 때마다 10씩 증가한다.
- AMateria를 이용해 ICE와 CURE를 만들어라. 각 타입은 소문자 ice로 해야한다.
- clone()메소드는 새로운 인스턴스를 반환해야한다.

use(ICharacter&) 메소드는 다음과 같이 출력한다

- ice : * shoots an ice bolt at NAME *
- Cure: * heals Name's wounds *

Character은 다음과 같은 인터페이스를 따른다. 문제에 주어짐

- 캐릭터는 최대 4개의 Materia 인벤토리를 갖고 처음엔 비어있다. 순서대로 0~3 마테리아에 장착한다.
- 가득 차거나 비어있는 경우 장착, 해제할 떄 아무 일도 하지 않도록 함. ⇒ 예외처리
- unequip는 delete 하지 마라 ⇒ NULL값으로 초기화 시킴.
- use(int ICharacter& ) 메소드는 인덱스에 해당하는 마테리아를 사용하고 타겟을 Amateria::use 메소드로 넘겨줘라.
- 

```jsx
this->inventory[idx]->use(target);
AMateria를 인스턴스한 ICE나 CURE의 use메소드를 사용하는 것 
=> 여기서 다시 AMateria::use(target)로 넘겨준다
=> 해당 materia의 xp를 +10
```

- 캐릭터는 name을 파라미터로 갖는 생성자를 가져야하고 복사나 대입연산자가 구현되어야함 ⇒ 물론 deep cpy로.
- 캐릭터 소멸될 때 Materia도 같이 소멸해야함.

IMateriaSource 인터페이스로 Materia를 생성한다.

- 배웠던 것들을 기억할 AMateria 4개 객체포인터 생성
- learnMateria로 들어온 Ice, Cure객체를 AMateria 객체배열에 저장해두고 있음.
- createMateria로 해당 타입에 해당하는 객체를 새로운 메모리를 반환해 AMateria 포인터가 가리키게 만든다
- 캐릭터가 AMateria를 장착한다 ⇒캐릭터의 AMateria배열에 차곡차곡 저장한다.

메모리가 할당된 부분은 IMateriaSource안의 AMateria 배열안에 new Ice, new Cure가 할당되어있고 이를 캐릭터의 AMateria배열이 가리키게 만든것.

따라서 IMateriaSource 객체 메모리해제하면 이를 가리키는 공간 모두 다 포함되기에 src만 지워주면 됨.

learnMateria는 Materia를 인자로 받아 복사한다. 메모리에 복사되어야함.

Source는 4개의 마테리얼을 알고 있어야함. ⇒ 4개의 마테리아 배열에 하나씩 쌓아둠.

createMateria은 새로운 마테리아를 반환한다. 이건 마테리아가 복사되어야함 ⇒ 인자로 넘겨준 type에 해당하는 마테리아가 새로운 메모리로 반환됨.

캐릭터 equip에 createMateria로 생성된 AMateria객체를 인벤토리에 착용함.

use(idx, *target)로 해당 캐릭터의 마테리아 xp가 +10됨.

---

###### 7. 학습 내용에 대한 개인적인 총평

-  cpp 04 과제 내용을 해석하고 구현했다. 과제에 대한 설명이 정말 부족한 것 같다.
-  구현보다 해석이 더 오래 걸린다

###### 8. 다음 학습 계획

- Cpp05