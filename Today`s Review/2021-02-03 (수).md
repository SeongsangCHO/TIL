

###### 1. 학습 날짜

- 2021 - 02 - 03(수)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- cpp06

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- cpp06

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# 타입변환 연산자

static_cast<바꾸려고 하는 타입>(대상)

실수,정수, 열거형 정수, 실수 실수 사이의 변환 드응ㄹ ㅓㅎ용함.

```jsx
double d = 13.24;
float f = 10.12f;

int tmp_int;

tmp_int = static_cast<int>(d); => double to int 형변환
```

std::isnan(float arg) ⇒ arg가 number가 아니면 false

std::isinf(float arg) ⇒ arg가 무한대면 true (INFINITY), exp(800)

# 자료형을 맘대로 갖고 놀 수 있는 템플릿.

자료형에 따라 각 함수를 구현할 필요없이 함수템플릿을 사용하면 하나의 함수만 정의하면 됨

```jsx
template <typename 사용할 이름>

T sum(T a, T b){
	return a + b
}
cout << sum<int>(a,b) << endl; //<자료형 명시>
//템플릿 변수가 2개이상이면 컴파일러가 스스로 자료형을 판단함.
```

### 뽀나스룰

- 각 예제는 모든 캐스트 상황은 특정 캐스트에 의해 해결되어야함
- 평가는 니가 구현한 것과 예상값이 일치하는지 확인하면된다.

# ex00

- make파일을 포함한 어떤 파일 제출++
- string to int, float or double 하기 위한 어떤 함수 사용해도됨.

C ++ 리터럴 값 (가장 일반적인 형식)의 문자열 표현을 매개 변수로 사용하는 프로그램을 작성합니다. 이 리터럴은 char, int, float 또는 double과 같은 스칼라 유형 중 하나에 속해야합니다. 십진수 표기법 만 사용됩니다

char 예제

- 인자로 문자를 받을 수도 있는데 char형으로 표기될 수 있어야한다.

int 예제

- 0, -42, 42넣어도 됨.

float예제

- 0.0f, -4.2f, 4.2f -inff, '+'inff,nanf는  은 안되는걸로

double

- 0.0, -4.2 , 4.2 ehla. -inf, '+'inf, nan
- 

# ex01

### reinterpret_cast<바꿀 타입>(대상)

- reinterpret_cast는 **임의의 포인터 타입끼리 변환을 허용**하는 캐스트 연산자 입니다.또한 **정수형을 포인터로 바꿀 수도** 있습니다. (이때 정수값이 포인터의 절대 주소로 들어가게 됩니다. -> 위험)
- **expression에 해당하는 것을 new_type으로 비트단위로 바꾸는 것 입니다.**
- 다른 형태의 포인터로 변경이 가능하기 때문에 결과 값이 잘못 사용하는 경우에는결과 값이 컴파일러에 따라 다를 수도 있고, 예상하지 않는 값이 나올 수 있습니다.

https://blockdmask.tistory.com/242

void * serialize (void);"함수를 작성하세요. 이 함수는 직렬화 된 데이터 조각을 나타내는 바이트 시퀀스 힙의 주소를 반환합니다. 직렬화 된 데이터는 8 개의 영숫자 문자로 구성된 임의 배열, 임의의 정수 및 8 개의 영숫자 문자로 구성된 두 번째 임의 배열의 연결입니다. 임의의 값을 생성하기 위해 원하는 것을 자유롭게 사용하십시오. "Data * deserialize (void * raw);"함수를 작성합니다. 이 함수는 원시 데이터를 "struct Data {std :: string s1; int n; std :: string s2;};"로 정의 된 데이터 구조로 역 직렬화합니다. 힙에 할당되었습니다. 이 두 함수를 모든 것이 의도 한대로 작동 함을 증명하는 프로그램으로 묶습니다

std::string (const char* s, size_t n);

- n개의 문자를 char 포인터 s로부터 복사해온다.

평가 : void *가 가리키는 원시 데이터는 힙에서 연속적인 20 바이트 여야합니다.(8 + 4 + 8)

- 8개의 영+숫자로 표현된 배열,

# ex02

### dynamic_cast

부모 클래스의 포인터에서 자식 클래스의 포인터로 다운 캐스팅 해주는 연산자 입니다.

dynamic_case<바꾸려는 새로운 타입>(대상)

- ex) dynamic_cast<childClass*>(pParent*);
- 성공할 경우 : new_type의 value를 return 합니다.
- 실패할 경우(new_type = pointer) : null pointer
- 실패할 경우(new_type = reference) : bad_cast (exception 처리됩니다.)
- public virtual 소멸자만 소유하는 클래스 Base를 만듭니다. Base에서 공개적(public)으로 상속하는 세 개의 빈 클래스 A, B 및 C를 만듭니다.
- `Base * generate (void);`함수를 작성하십시오.
  - A, B 또는 C를 무작위로 인스턴스화하고 인스턴스를 Base 포인터로 반환합니다. 임의성을 위해 원하는 것을 자유롭게 사용하십시오.
- `void identity_from_pointer (Base * p);`함수를 작성합니다. p의 실제 유형에 따라 "A", "B"또는 "C"를 표시합니다.
- `void identity_from_reference (Base & p);`함수를 작성합니다. p의 실제 유형에 따라 "A", "B"또는 "C"를 표시합니다.

이 세 가지 기능을 모든 것이 의도 한대로 작동 함을 증명하는 프로그램으로 묶습니다. <typeinfo>를 포함하는 것은 금지되어 있습니다

---

###### 7. 학습 내용에 대한 개인적인 총평

- 타입변환 연산자에 대해 학습했다.

###### 8. 다음 학습 계획

- Cpp07