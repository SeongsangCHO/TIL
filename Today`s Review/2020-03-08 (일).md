---
###### 1. 학습 날짜

- 2020-03-08(일)
 
---
###### 2. 학습시간

- 15:00 ~ 23:00 (자가)

---
###### 3. 학습 범위 및 주제

-  인프런 스프링프레임워크 강의 4강씩 수강 및 정리, printf 동작원리

---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스프링프레임워크 학습

---
###### 6. 과제 제출 repository 주소

http://13.125.198.2:3000/secho/get_next_line.git

---
###### 7. 상세 학습 내용

- 코드작성시간 : 2시간      

## DI

- Dependency Injection은 객체 사이의 **의존 관계**를 **스프링 설정 파일에 등록된 정보**( <bean> )를  **바탕으로 컨테이너가 자동으로 처리**해 준다. 따라서 의존성 설정을 바꾸고 싶을때 프로그램코드를 수정하지 않고 스프링 설정 파일 수정만으로 변경 사항을 적용할 수 있어서 유지보수가 향상된다. 



출처: https://backback.tistory.com/161 [Back Ground]

- https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html 

#### 다양한 의존객체주입 방법

- 생성자를 이용한 의존객체주입

- setter를 이용한 의존객체주입

- List타입 의존객체주입

- Map타입 의존객체주입

  

  

  ##### 생성자를 이용한 의존객체주입 (construct-arg 태그를 이용하는 방법)

  ```java
  public StudentRegeisterService(StudentDao studentDao){
  	this.studentDao = studentDao;
  }
  <bean id = "studentDao" class="패키지 네임.StudentDao"></bean> //bean init
  <bean id = "registerService" class ="패키지네임.StudentRegisterService">
   <constructor-arg ref="studentDao(주입할 스프링컨테이너의 객체(빈으로 등록된))"> </contructor-arg>
  ```

  StudentRegeisterSerivce객체의 생성자를 수행할 때 studentDao 객체를 주입하는 방법.

  <XML파일 내>

  studentDao 객체를 생성한다.

  registerService 객체를 생성할 때 <constructor-arg>태그를 통해 주입하려는 id값을 넣어주면 그 안에 객체가 주입된다.



##### setter를 이용한 의존객체주입

```java
public void setJdbcUrl(String jdbcUrl){
	this.jdbcUrl= jdbcUrl;
}
public void setUserId(String userId){
	this.userId= userId;
}
public void setUserPw(String userPw){
	this.userPw= userPw;
}
//= >
```

```xml
<bean id = "dataBasConnectionInfoDev" class ="packagename">
    <property name ="jdbcUrl" value ="jdbc:oracle~~~"/>
    <property name ="userId" value ="scott"/>
    <property name ="userPw" value ="파라미터로 들어가는 값"/>
</bean>
```

프로퍼티 태그를 이용한다 - > set을 띄고 첫글자를 소문자로 바꿔서 name속성값으로 이용한다.

parameter로 들어가는 값을 value의 속성값으로 지정해서 사용함.



##### List 타입 의존객체주입

```java
public void setDeveloper(List<String> developers){
	this.developers = developers;
}
```

```xml
<property name ="developers">
 <list>
 	<value>Cheney</value>
 	<value>hell</value>
 	<value>world</value>
  </list>
 </property>
```



##### Map타입 의존객체주입

```java
public void setAdministors(Map<String, String> administrators){
	this.administors = administors;
}
```

```xml
<property name ="administrators">
 <map>
  <entry>
   <key>
 	<value>Cheney</value>
   </key>
 	<value>hell</value>
   </entry>
     
   <entry>
    <key>
 	<value>dev</value>
    </key>
 	<ref bean = "dataBaseConnectionInfoDev"/> //객체주입
   </entry>
  </map>
 </property>
```

프로퍼티 네임 set제외 첫글자 소문자. -> setter함수의 네임

key, value쌍을 이뤄서 의존객체주입

객체를 주입할 수 있다.



### 스프링 설정파일 분리

applicationContext.xml ->appCtx1, appCtx2, appCtx3으로 분리.

How to?

- 기능별로 구분해서 bean단위로 분리하면됨

- 스프링컨테이너를 생성하는 방법은 문자열 배열을 만들어서 GenericXmlApplicationContext("str");로 한꺼번에 넣어주면됨

- ```xml
  <import resource="classpath:appCtx2.xml"/>
  <import resource="classpath:appCtx2.xml"/>//으로 하는 방법도 있음
  ```

  

### 빈(Bean)의 범위

- 싱글톤: 스프링 컨테이너에서 생성된 빈(Bean)객체의 경우 동일한 타입에 대해서 기본적으로 "한 개"만 생성이 되며 getBean()메소드로 호출 될 때 동일한 객체가 반환 된다. => new키워드를 통해 여러 객체를 생성하는 것 말고 genericXmlContext를 통해 스프링컨테이너안의 빈 객체들이 생성이 되고 이를 호출할 때  getBean메소드를 통해서 다른(새로 만든) 객체가 반환되는 것이 아닌 기존에 만든 동일한 객체가 반환되는 것. => 이와 반대되는 프로토타입

- 프로토타입: 싱글톤 범위와 반대됨, 개발자가 별도로 설정, xml에서 빈(bean)객체를 정의할 때 scope속성을 명시. **호출할 때마다 다른 객체를 새로 생성**

- ```xml
  <bean id ="beanid" class="packagename"
   scope="prototype">
   <constructor-arg ref ="refrence"/>
   <property name ="name" ref="refname"/>
   </bean>
  ```

  

### 의존객체 자동 주입

- 스프링 설정 파일에서 의존 객체를 주입할 때 <constructor-arg, property>태그로 의존 대상 객체를 명시하지 ㅇ낳아도 스프링컨테이너가 자동으로 필요한 의존 대상 객체를 찾아 객체가 필요한 객체에 주입해 주는 기능.
- @Autowired, @Resource어노테이션을 이용해 쉽게 구현할 수 있다.



### @Autowired

- 주입하려고하는 **객체의 타입이 일치**하는 객체를 자동으로 주입

- ```xml
  어노테이션을 사용하기 위해서 스프링설정파일에서 
  xmlns:context="http://www.springframework.org/schema/context" , xsi:schemaLocation = //namespace추가
  
  <context:annotation-config /> //해당부분추가
  ```

- 생성자에는 해당 어노테이션  사용가능하지만 메소드나 프로퍼티에 사용할 때는 **디폴트생성자** (매개변수 없는 생성자)를 선언해주어야함.

- 의존객체 (Bean으로 등록된 것)이 없을 때

### @Resource

- 주입하려고하는 **객체의 이름이 일치**하는 객체를 주입
- 생성자에는 사용 불가능. 프로퍼티나 메소드에 사용, 디폴트생성자를 선언해주어야함!

### 의존객체 선택

- 동일타입 객체가 2개 이상인 경우 스프링컨테이너는 자동주입대상을 판단하지 못해 Exception을 발생시킨다.

- ```xml
  <bean id ="wordDao1" class="packagename">
  	<qualifier value = "usedDao"/>
  </bean>
  <bean id ="wordDao2" class="packagename">
  <bean id ="wordDao3" class="packagename">
  
  ```

  ```java
  @Autowired
  @Qualifier("usedDao")//xml의 qualifier으로 주입대상결정
  private WordDao wordDao
  ```

  이름이 동일하면 상관없음
- zsh- history 오류 발생 - 참고 https://superuser.com/questions/957913/how-to-fix-and-recover-a-corrupt-history-file-in-zsh 해당 명령어로 해결

---
###### 8. 학습 내용에 대한 개인적인 총평

- 스프링의 DI에 대해서 학습을 진행했다. Bean객체를 스프링설정파일에서 선언하고, 어노테이션을 사용해 개발자가 쉽게 주입할 수 있는 방법에 대해서 알게되었다. 이를 이용하여 여러 객체를 선언하여 메모리낭비없이 객체 재사용을 할 수 있을 것같다. 표준입력에 대해서 정확히 명시가 안되어있는것 같아 아직 진행은 하지않았다. 명령인수를 통해 다중파일을 읽을 수 있도록 구현은 해놓은 상태이다. printf를 가변인수함수라고 한다. 인수의 갯수나 타입이 모두 다르지만 실행이 된다. 이를 가변인수함수라고 한다. man page를 참고하니 생각이상으로 printf가 변환하는 인자가 많았다 이에 대하여 일일히 정리해야할 것 같다. http://egloos.zum.com/michinblog/v/10120551

---
###### 9. 다음 학습 계획 (최소 5줄 이상)

- ft_printf 내용정리
- 표준입력구현해보기
- bouns파트 구현
- 인프런 스프링프레임워크 강의 4강씩 수강 및 정리
- 동료들과 코드비교 및 오류처리방법 토의
- 여러 테스트케이스를 만들어 생각하지 못한 예외처리를 할 것.