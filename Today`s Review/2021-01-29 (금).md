###### 1. 학습 날짜

- 2021 - 01 - 29(금)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 캐노니컬 폼

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- Cpp 클래스 표현방법인 캐노니컬 폼에 대해서 학습

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

# 캐노니컬 폼

AClass a  ⇒ a.value =0;

AClass b(a); ⇒

AClass b;

b = a; ⇒  a.value ⇒ char *str[10];  b = str, & a.value == & b.value;*

1 ⇒ 삭제 2번. ⇒ compile error!

- Default constructor
- Copy constructor
- Destructor
- Copy assignment operator

```jsx
// 스켈레톤
class A final
{
   public:
      A ();
      A (const A &a);
      ~A ();
      A & operator = (const A &a);
};

//내용
class A final
{
   public:
      A () = default; //기본 생성자
      A (const A &a) { member = new B (a.member); } // 복사생성자 
//=> 대입연산자 수행될 때 메모리 새로 할당. 포인터가 겹치지 않게
      A & operator = (const A &a) // 대입연산자 오버로딩
      {
         if (this != &a) //대입된 거랑 현재 객체랑 다르다면,
         {
            delete member; //현재 객체 삭제 후 새로 할당
            member = new B (a.member);
         }

         return *this;
      }
      ~A () { delete member; } // 소멸자
  
  private:
      B *member = new B ();
};
```

# 복사생성자

복사생성자가 호출될 때는

**1. 대입연산을 할 때**

**2. 매개 변수로 들어갈 때**

**3. 반환 값이 있을 때**

```jsx
//default 복사 생성자
0x7ffeeedd87c8 Default constructor called
0x7ffeeedd87b8 Default constructor called
0x7ffeeedd87c0 Assignation operator called 
Destructor called
Destructor called
Destructor called
//정의한 복사생성자 
0x7ffeed6997c8 Default constructor called
0x7ffeed6997c8 Copy constructor called
0x7ffeed6997b0 Default constructor called
0x7ffeed6997c0 Assignation operator called 
Destructor called
Destructor called
Destructor called
```

- 다른 객체로부터 값을 복사해 초기화
- 반환형이 없다
- 기본 자료형은 괜찮으나 객체 등 복사하면 문제 있음
- 값만 복사되는 것, 메모리 주소가 새로 할당되지 않음
- 연산자 오버로딩에서 다룸 (기본적으로 디폴트로 구현되어있음)
- 얕은복사 예제

```jsx
Test B(A)
클래스명 생성할 객체(이미 생성된 객체)

TestClass(const TestClass& tc) {
	num = tc.num;
}

출처: <https://itmining.tistory.com/51> [IT 마이닝]
```

# 소멸자

- 소멸자에서 메모리 해제해주는 역할담당

# 연산자 오버로딩

`operator` 로 + - & 등 연산자 재정의할 수 있음.

객체에서 대입연산자를 사용하면 디폴트로 정의된 멤버 대 멤버 얕은 복사가 이뤄진다

```jsx
A a1(10, 50);
A a2;

a2 = a1;
a2 => (10, 50)// 얕복
```

얕은 복사를 사용하면 발생하는 문제

생성자에 동적할당을 해서 문자열을 초기화해준다고 했을 때 대입연산자로 얕은 복사를 하면 새로 생성되는 것이 아닌 원래 가리키고 있던 문자열이 새로 대입되는 문자열을 가리키게되고, 메모리해제시에 생성된 메모리는 하나밖에 없는데 중복 소멸시킬 수 있는 문제가 발생함

`&` 연산자를 재정의해서 깊은 복사로 대입연산을 할 수 있음

```jsx
Student &Student::operator=(const Student& ref)
{
	delete []name; // 기존 할당된 메모리 반환
	name = new char[10]; // 새로 할당
	strcpy(name, ref.name); // 대입되는 객체의 멤버변수 복사
	age = ref.age; // "
	return *this; //객체 포인터 반환
}

출처: <https://blog.hexabrain.net/177> [끝나지 않는 프로그래밍 일기]
```

값이 복사되어도 다른 메모리 주소를 가진다.

---

###### 7. 학습 내용에 대한 개인적인 총평

-  대입연산자 오버로딩, 복사생성자에 대해서 학습하고 이를 적용한 클래스 표현식인 캐노니컬폼을 구현해보았다.

###### 8. 다음 학습 계획

- Cpp04, 다중상속, virtual, 객체지향 코드작성