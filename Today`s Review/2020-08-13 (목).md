

###### 1. 학습 날짜

- 2020 - 08 - 13(목)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- 리덕스 적용 완료 및 총정리

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- 리덕스 적용을 완료하고 정리한다.

---

###### 6. 상세 학습 내용

- 코드작성시간 : 8 시간

## React #13 리덕스 + Axios로 상태관리하기



<br>

앞서 정리했던 리덕스를 실제로 프로젝트에 적용해보고 사용해보도록 하겠다.

여러 글을 참고하고 진행하였으며 어떤 형식이 옳은지, 어떻게 사용해야 정답인지는 아직 잘 모르겠다.

글만보면서 이해하려하는 것 보다 직접 자료를 찾아가면서 실제 코드에 적용을 해보는 과정을 통해 이해하는데 많은 도움이 되었다.



<br>

직접 작성하며 동작하는 순서대로 정리함.

<br>

총 단계는 다음과 같다.

1. 스토어 생성
2. 리덕스 래퍼 적용
3. 리듀서 생성
4. 액션 생성함수 작성
5. Dispatch로 생성한 action을 리듀서로 전달
6. 반환받은 새로운 상태로 데이터 출력

<br>

폴더구조는 다음과 같다.

- redux
  - actions
  - reducers
  - store

<br>

### 1,2단계 : 스토어 생성, 리덕스 래퍼 적용하기

상태관리를 해주는 스토어를 생성한다.

스토어를 딸랑 생성하는 것보다 도움이 되는 라이브러리를 추가해주는 것이 좋다.

현재 사용하고 있는 라이브러리는 **비동기 작업**을 돕는 **Redux-thunk**와 State, Props등을 콘솔에서 보여주는 **Logger** 그리고 크롬 익스텐션인 **Redux-devtools**를 사용할 수 있도록 하는 **composeWithDevTools**를 사용하도록 하겠다.



next에서 Redux를 쉽게 사용할 수 있도록 도와주는 `redux-wrapper`을 설치한다.

`npm i next-redux-wrapper`

미들웨어도 설치한다.

`npm i redux-logger`

`npm i redux-thunk`

`npm i reudx-devtools-extension`



```javascript
const configureStore = () => {
  const logger = createLogger();
  const middlewares = [thunk, logger]; //thunk (비동기작업을 돕는 라이브러리)를 넣음
  //배포용과 개발용의 미들웨어 차이를 두기 위함
  const enhancer = process.env.NODE_ENV === 'production'
  ? compose(applyMiddleware([]))
  : composeWithDevTools(applyMiddleware(...middlewares))//middlewares배열을 여기다가 넣음.
  
  const store = createStore(
    combineReducers({
      reducer,
      faqReducer,
      programsReducer}), enhancer);
  return store;

};

const wrapper = createWrapper(configureStore, {
  debug: process.env.NODE_ENV === 'development',
});

export default wrapper;
```





- 스토어를 생성할 때 여러 리듀서를 한꺼번에 통합해주는 `combineReducers`. => 사용할 리듀서를 인자로 받는다.

  combine을 해주면 스토어에서 합쳐진 리듀서들의 상태를 하나로 관리할 수 있다.

- `enhancer`은 리덕스에 미들웨어를 추가하기 위한 인자이다.

- 추가된 기능을 가진 스토어를 생성하고 이를 이용해서 `_app.js`에서 wrapper로 감싸줌으로써 리덕스 적용이 완료된다.

  - ```javascript
    export default wrapper.withRedux(MyApp);
    
    ```

    

기존의 방식은 `<Provider/>`으로 감싸주어야 하는 것. 이 부분이 `next Redux`에서 사용하는 `리덕스 래퍼`와 차이점이다.



<br>



### 3단계 : 리듀서 생성

<br>

변화를 일으키는 함수. 즉, 상태를 받아와서 새로운 상태로 반환하는 기능을 하는 함수이다.

여기서 변화될 상태는 데이터가 없던 상태에서 API를 호출해 받아온 데이터를 넣은 새로운 상태를 의미한다.

```javascript
import { HYDRATE } from 'next-redux-wrapper';
//faq리듀서의 초기 State지정
const initialState = {
  data: {}
};

//상태가 변화할 때 수행되는 함수
//Type에 따른 상태변화
const faqReducer = (state = initialState, action) => {
  switch (action.type) {
    case HYDRATE:
      return { ...state, ...action.payload };

    case 'GET_FAQ_DATA':
      return { ...state, data: {...action.payload} };

    default:
      return state;
  }
};
export default faqReducer;
```

<br>

- `initialState`는 리듀서의 초기 상태를 의미한다.
- `faqReducer`의 동작은 `action.type`에 따라 기존상테(`initialState`)에서 새로운 상태 `{ }`로 반환한다는 의미이다. `{ }`로 감싸어져서 반환된다는건 새로운 객체를 생성해 반환함을 의미한다.
- `{...state}`의 `...`은 변화된 상태만을 받는다는 의미이다. `state`에 변화가 없다면 기존값 그대로 반환한다.

- `GET_FAQ_DATA`의 값을 가지는 `action`이 수행되면 `return {...}`을 한다는 의미.

<br>

### 4단계 : 액션생성함수 작성

<br>

이전에 `type`을 필수로 가지는 객체를 `액션`이라고 했다.

이 `액션`에 따라 리듀서에 정의된 동작을 분기하게 되는데 `액션생성함수`란 이 `액션`객체를 생성하는 함수를 의미한다.

```javascript
//actions/faqAction.js
import axios from 'axios';
//액션(type을 가진 객체) 생성함수
//API를 호출해서 JSON데이터를 가져오고 리듀서에 해당 상태를 변화시키기 위한 TYPE을 지정해줌
export const getFaqData =  async () => {
  //API 호출
  const faqData = await axios.get('http://localhost:5000/api/json/faq');
  return {
    type: 'GET_FAQ_DATA',
    payload : faqData.data
  }
}

```

<br>

비동기처리를 위해 `async, await`로 axios 라이브러리를 통해 API를 호출하여 `faqData`로 데이터를 반환받았다.

변화된 상태를 반환할 액션타입을 지정해주고, `payload`에 반환받은 데이터를 할당해주었다.

<br>

### 5단계 : Dispatch로 action 전달.

<br>

4단계를 통해 생성한 액션안에는 새로운 상태로 만들수 있는 데이터, 그리고 type을 갖고 있다.

이 액션을 리듀서로 전달해 새로운 상태를 반환받아보자!

<br>

그럼 먼저 3단계에서 지정한 `initialState`를 불러와보자. 왜? 변화된 상태를 받아오기 위해서 먼저 상태를 받아오는 작업이 있어야하기 때문.

상태를 가져오기 위해서는 앞 장에서 설명한 `useSelector`을 사용하면 된다.

```javascript
  const faqData = useSelector((state) => state.faqReducer);
```

`state`란 스토어의 상태이고 콘솔 찍어보면 combine된 모든 리듀서들의 상태가 전부 나오게 된다

우리는 faqReducer의 상태만 받아올 것이므로 위와 같이 작성한다.



그럼 다 된거아냐? 여기다가 액션생성함수로 액션 생성해서 바로 dispatch로 반환된 새로운 상태(데이터)를 가지고 컴포넌트를 랜더링하면 되잖아?

응, 안된다.



<br>



---

###### 7. 학습 내용에 대한 개인적인 총평

- 리덕스 적용을 하면서 내용 정리했다. 아직 마무리되지 않아 내일 정리를 마무리할 예정이다.

###### 8. 다음 학습 계획

- 리덕스 정리

