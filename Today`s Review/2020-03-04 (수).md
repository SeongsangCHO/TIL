---
###### 1. 학습 날짜

- 2020-03-04(수)
 
---
###### 2. 학습시간

- 13:00 ~ 19:00(자가)

---
###### 3. 학습 범위 및 주제

- get_next_line 구현 및 메모리 이슈 체크

---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- get_next_line 구현

---
###### 6. 과제 제출 repository 주소

http://13.125.198.2:3000/secho/get_next_line.git

---
###### 7. 상세 학습 내용

- 코드작성시간 : 4시간
## 파일디스크립터

-   운영체제가 만든 파일 또는 소켓의 지칭을 편히 하기 위해서 부여된 숫자이다.
    
-   파일디스크립터를 파일핸들이라고도 하는데, 핸들이라는 표현은 윈도우에서 사용되는 용어임.
    
-   기본적으로 파일 디스크립터는 정수형으로 차례로 넘버링 되고 0,1,2는 이미 할당되어 있어서 3부터 파일 디스크립터를 부여한다.
    
    FD  
    0 표준입력 : Standard Input  
    1 표준출력 : Standard Output  
    2 표준에러 : Standard Error
    

## read() 파일 읽기

-   ssize\_t read(int fd void \*buf, size\_t bytes)
-   fd 파일 디스크럽터, buf 읽어올 버퍼, bytes 버퍼의 크기
-   리턴값: 읽어오는데 성공이면 읽어온 바이트 수, 실패: -1

## gcc -d 정의 명

-   외부에서 #define을 정의한다. 해당 문제에서는 buffersize를 정의 . 참고 : [http://egloos.zum.com/sunnmoon/v/1825047](http://egloos.zum.com/sunnmoon/v/1825047)

#### 문제해석

-   개행없이 파일 디스크립터에서 읽은 라인을 리턴하는 함수를 작성.

-   fd의 텍스트를 EOF전까지 개행문자기준으로 한 줄씩 읽을 것.
    
-   파일을 읽거나, 표준입력을 받아야함.
    
-   read함수는 BUFFER\_SIZE를 이용한다. 해당 사이즈는 gcc -d 옵션으로 지정한다.
    
-   버퍼사이즈가 1,9999,1000000일 때 잘 작동하는지 여부 확인, 왜인지까지도 확인하기.
    

<table style="border-collapse: collapse; width: 76.0466%; height: 321px;" border="1" data-ke-style="style15"><tbody><tr style="height: 19px;"><td style="width: 50%; height: 10px; text-align: center;">함수명</td><td style="width: 50%; height: 10px; text-align: center;">get_next_line</td></tr><tr style="height: 39px;"><td style="width: 50%; height: 39px; text-align: center;"><b>프로토타입</b></td><td style="width: 50%; height: 39px;">int get_next_line(int fd, char **line);</td></tr><tr style="height: 59px;"><td style="width: 50%; height: 59px; text-align: center;"><b>제출 파일</b></td><td style="width: 50%; height: 59px;">get_next_line.c get_next_line_utils.c, get_next_line.h</td></tr><tr style="height: 19px;"><td style="width: 50%; height: 19px; text-align: center;"><b>매개변수</b></td><td style="width: 50%; height: 19px;">파일 디스크럽터, 읽어온 값</td></tr><tr style="height: 175px;"><td style="width: 50%; height: 175px; text-align: center;"><b>반환 값</b></td><td style="width: 50%; height: 175px;"><p>1: A line has been read</p><p>0: EOF has been reached</p><p>-1: An error happend&nbsp;</p></td></tr><tr style="height: 19px;"><td style="width: 50%; height: 19px; text-align: center;"><b>허용함수</b></td><td style="width: 50%; height: 19px;">read, malloc, free</td></tr></tbody></table>

---
###### 8. 학습 내용에 대한 개인적인 총평

- gcc -D옵션을 통해 버퍼사이즈를 조절하여 read함수에서 읽어온 데이터 수를 가변적으로 조절할 수 있는데 구현한 함수에서는 메모리누수 그리고 특정 값 이상으로 올라가게 되면 에러가 발생하게 된다. 원인을 파악하기 위해서 다시 코드를 보고 동료학습을 진행해야할 것 같다. free되는 부분이 할당부분보다 많다고 나와있었다. valgrind를 설치하여 해당부분을 확인할 수 있었다. 이외에도 sh를 통해 메모리누수점검을 진행할 수 있지만 해당 소프트웨어가 더 편리하다고 생각한다.
print를 찍어보면서 함수호출에 대해서 계속 확인했지만 어디서 에러가 발생되는지 아직은 찾을 수 없었다. 문자열에 대한 메모리할당에 좀 더 고민을 해보고 진행해야할 것 같다.

---
###### 9. 다음 학습 계획 (최소 5줄 이상)

- 메모리 이슈 체크
- get_next_line 구현
- 메모리부분 추가 학습
- 동료들과 코드비교 및 오류처리방법 토의
- 여러 테스트케이스를 만들어 생각하지 못한 예외처리를 할 것.