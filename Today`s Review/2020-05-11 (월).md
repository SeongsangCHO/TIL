---
###### 1. 학습 날짜

- 2020-05 -11(월)
 
---
###### 2. 학습시간

- 16:00 ~ 23:00(자가)

---
###### 3. 학습 범위 및 주제

- 스프링
---
###### 4. 동료 학습 방법 

- slack (saji, yshin, Jiyang, Seongkim)

---
###### 5. 학습 목표 

- 스프링

---
###### 6. 상세 학습 내용

- 코드작성시간 : 6 시간
## 코드로 배우는 스프링프레임워크

## XML을 이용하는 의존성 주입(05.11)

스프링은 클래스에서 객체생성, 객체들의 의존성 처리작업까지 내부에서 처리됨

root-context.xml(bean을 설정하는 설정파일)

위 파일클릭 후 nameSpaces탭에서 context 체크 후 source 추가

```xml
	<!-- Root Context: defines shared resources visible to all other web components -->
		<context:component-scan base-package="org.zerock.sample">
		</context:component-scan>
```

해당 작업 완료후 하단의 bean graph 탭에 Restaurant, Chef객체가 설정된 것 을 확인할 수 있다.

![bean graph](https://user-images.githubusercontent.com/55486644/81533037-6f534500-93a0-11ea-80f8-222d8aaf1796.JPG)



## JAVA를 이용하는 의존성 주입

java 설정에서는 root-context 대신하는 RootConfig클래스.

@ComponentScan 어노테이션을 이용해, 기존 xml에서 설정된 내용을 처리할 수 있다.

```java
@Configuration
@ComponentScan(basePackages = {"org.zerock.sample"})
public class RootConfig {
}

```





스프링이 시작되면, 스프링이 사용하는 메모리 영역을 만들게 된다.

이 메모리 영역은 컨텍스트라고 한다. , 스프링에서는 ApplicationContext라는 객체가 생성된다.

그렇다면 스프링이 객체를 생성 및 관리해야하는 객체들의 설정이 필요한데, 이 설정은 root-context에서 할 수 있다.

root-context에 설정되어 있는 context-scan 태그를 통해, "패키지명"을 스캔하기 시작한다.

해당 패키지에 있는 클래스 중에서 @Component라는 어노테이션이 존재하는 클래스의 인스턴스를 생성한다.

- 인스턴스 : **객체**가 메모리에 할당되어 실제 사용될 때를 말한다.

Restaurant객체는 Chef객체가 필요하다는 어노테이션설정이 있으므로, 스프링은 chef객체의 레퍼런스를 Restaurant 객체에 주입한다.



#### 테스트 코드

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
@Log4j
public class SampleTest {
	@Setter(onMethod_ = {@Autowired})
	private Restaurant restaurant;
	
	@Test
	public void testExist() {
		
		assertNotNull(restaurant);
		
		log.info(restaurant);
		log.info("------------------");
		log.info(restaurant.getChef());
	}
}

```

@RunWith - > 테스트코드가 스프링을 실행하는 역할을 할 것

@ContextConfiguration 지정된 클래스 또는 문자열을 이용해 객체를 스프링 내의 객체로 등록.(빈 등록)

@Log4j 로그를 기록함

assertNotNull(변수) 해당 변수가 NULL이 아니어아먄 테스트가 성공.

## JAVA 테스트

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {RootConfig.class})
@Log4j
public class SampleTests{
...
}
```

## 스프링 #02 Lombok 및 어노테이션 정리

컴파일시 코드를 작성하는 기능을 완성해주는 라이브러리

@Setter

- setter 메소드를 만들어 줌
- 3가지 속성 부여

value : 접근 제한 속성

onMethod : setter메소드 생성시 메소드에 추가할 어노테이션 지정

					예제에는 @Autowired 지정

onParam: setter 메소드의 파라미터에 어노테이션을 사용하는 경우에 적용.



@Data

- @Tostring, @EqulasAndHashCode, @Getter/ @Setter, @RequiredArgsConstructor 모두 생성

## 스프링 관련

@Component

- 해당 클래스가 스프링에서 객체로 만들어 관리하는 대상임을 명시
- @ComponentScan을 통해 패키지의 클래스들을 조사하면서 @Component가 존재하는 클래스들을 빈으로 관리

@Autowired

- 스프링 내부에서 자신이 특정한 객체에 의존적이므로, 해당되는 타입의 빈을 주입해주라는 표시
- Restaurant는 Chef타입 객체가 필요하므로 (@Setter(onMethod = @Autowired))private Chef chef; 이를 확인하고 자동으로 주입 - 그렇다면 스프링에서 이를 주입하기 위해서 관리하고있는 빈(객체)들을 주입해주어야하는데, 빈으로 등록하기 위해서는 Chef 클래스에 Component 어노테이션을 작성해주어야함



### 생성자 주입

@Autowired 대신 생성자 주입

```java
@Component
@ToString
@Getter
public class SampleHotel
{
	private Chef chef;
	
	public SampleHotel(Chef chef){
		this.chef = chef;
	}
}
```

생성자를 이용한 의존성 주입



생성자 자동주입 + LOMBOK

```java
@Component
@ToString
@Getter
@AllArgsConstructor
public class sampleHotel
{
	private Chef chef;
}

```

@AllArgsConstructor은 인스턴스 변수로 선언된 모든 것을 파라미터로 받는 생성자를 작성한다.

여러개의 인스턴스 변수들 중에서 특정 변수에 대해서만 생성작를 작성하고 싶다면, @NonNull과 @RequiredArgsConstructor을 이용할 수 있다.

```java
@Component
@ToString
@Getter
@RequiredArgsConstructor
public class sampleHotel
{
    @NonNull
	private Chef chef;
}

```

## 스프링 #03 오라클 DB 연동

- oracle data base 11g express 설치
  - https://www.oracle.com/database/technologies/xe-prior-releases.html
- sql developer 설치
  - 11g express가 설치된 경로에 다운로드
  - https://www.oracle.com/tools/downloads/sqldev-v192-downloads.html

계정 접속한 다음, 연동 확인을 위해

```
CREATE USER book_ex IDENTIFIED BY book_ex
DEFAULT TABLESPACE USERS
TEMPORARY TABLESPACE TEMP;
```

실행 하면, 테이블이 생성됨을 확인할 수 있다.

사용자 계정으로 특정 행위를 위해 권한 또는 role이 필요하므로 GRANT 구문으로 처리한다

```
GRANT CONNECT, DBA TO BOOK_EX
```

### 포트변경

Tomcat의 기본포트가 8080으로 되어있기 때문에, 오라클 포트를 변경해주어야한다.

```
select dbms_xdb.gethttpport() from dual;
```

을 작성해 현재 포트번호를 확인할 수 있다.

8080으로 나오는 경우 포트번호를 아래 구문으로 변경한다

```
exec dbms_xdb..sethttpport(포트번호); // 1000번이하 제외
```



### 프로젝트의 JDBC 연결

SQL Developer 경로의 jdbc/lib 폴더에 ojdbc8.jar파일을 프로젝트의 build path에 추가한다

add External jars로 추가

Deploymenty Assembly에도 마찬가지로 추가해준다





### JDBC, Java 테스트

```java
package org.zerock.persistence;

import java.sql.Connection;
import java.sql.DriverManager;

import org.junit.Test;

import lombok.extern.log4j.Log4j;

@Log4j
public class JDBCTests {

	static {
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	@Test
	public void testConnection() {
		try(Connection con = 
				DriverManager.getConnection(
						"jdbc:oracle:thin:@localhost:1521:XE",
						"book_ex",
						"book_ex")){
			log.info(con);
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}
}

```

### 커넥션 풀 (Hicari CP)


## 스프링 #04 MyBatis + 스프링 연동, (커넥션 풀 히카리CP)



#### 커넥션 풀 히카리 CP (XML을 이용하는 경우)

여러명의 사용자를 동시에 처리해야하는 데이터베이스 연결을 이용할때 커넥션 풀을 사용한다

DataSource라는 인터페이스를 통해 이를 사용하며,Hikari CP라는 커넥션 풀을 사용하기 위해 설정을 진행한다.

pom.xml에 Hikari CP 를 추가한다

```xml
	<dependency>
	    <groupId>com.zaxxer</groupId>
	    <artifactId>HikariCP</artifactId>
	    <version>2.7.4</version>
	</dependency>
```

root-context.xml에 히카리 CP의 설정을 작성한다

```xml
	<!-- 히카리 CP 빈 등록 -->
	<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
		<property name="driverClassName"
			value="oracle.jdbc.driver.OracleDriver">
		</property>
		<property name="jdbcUrl"
			value="jdbc:oracle:thin:@localhost:1521:XE"></property>
			<property name="username" value="book_ex"></property>
			<property name="password" value="book_ex"></property>
	</bean>	
		
	<!-- 히카리 CP 설정 -->
	<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource"
		destroy-method="close">
		<constructor-arg ref="hikariConfig"/>
		</bean>

```



### JAVA를 이용하는 경우

RootConfig 클래스와 @Bean을 이용해서 처리한다

- @Bean이 선언된 메소드의 실행 결과로 반환된 객체는 스프링의 bean으로 등록된다.

RootConfig.java

```java
@Configuration
@ComponentScan(basePackages = {"org.zerock.sample"})
public class RootConfig {

	@Bean // dataSource()의 반환값 dataSource객체를 빈으로 등록하겠다.
	public DataSource dataSource() {
		HikariConfig hikariConfig = new HikariConfig();
		hikariConfig.setDriverClassName("oracle.jdbc.driver.OracleDriver");
		hikariConfig.setJdbcUrl("jdbc:oracle:thin:@localhost:1521:XE");
		hikariConfig.setUsername("book_ex");
		hikariConfig.setPassword("book_ex");
		
		HikariDataSource dataSource = new HikariDataSource(hikariConfig);
		return dataSource; // dataSource객체가 Bean으로 등록됨
	}

}

```



### 테스트코드

```java
package org.zerock.persistence;

import static org.junit.Assert.fail;

import java.sql.Connection;

import javax.sql.DataSource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.zerock.config.RootConfig;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes= {RootConfig.class})
@Log4j
public class DataSourceTests {
	
	@Setter(onMethod_ = {@Autowired})
	private DataSource dataSource;
	@Test
	public void testConnection() {
		try (Connection con = dataSource.getConnection())
		{
			log.info(con);
		}
		catch(Exception e) {
			fail(e.getMessage());
		}
	}
}

```

.hikari.HikariConfig - Failed to load driver class oracle.jdbc.driver.OracleDriver from HikariConfig class classloader 에러가 발생했었음

- XML프로젝트에만 JDBC Driver의 jar파일을 추가해주어서, 해당 프로젝트에도 추가해주었더니 해결됐음.



### MyBatis와 스프링의 연동

MyBatis : SQL 매핑 프레임워크

- mybatis-spring(스프링에서 동작) - MyBatis(이 둘을 연결해줌) - DB

#### XML을 이용하는 경우

pom.xml에 mybatis-spring과 MyBatis라이브러리를 추가해준다

Mybatis에서 핵심적인 객체는 SQLSession, SQLSessionFactory



root-context.xml

```xml
		
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
	<property name="dataSource" ref="dataSource"></property></bean>
<!-- SqlSessionFactory을 등록하는 작업은 SqlSessionFactoryBean을 이용. Mybatis의 패키지가 아닌, 스프링과 연동작업을 처리하는 mybatis-spring라이브러리이다.-->
<mybatis-spring:scan base-package="패키지경로">
</mybatis-spring:scan> <!-- 지정된 패키지의 모든 mybatis관련 어노테이션을 찾아 처리한다. -->
```

테스트코드는 아래의 java경우에서 .contextconfiguration의 문자열 부분만 수정하여 테스트하면 된다.





#### JAVA를 이용하는 경우

RootConfig 클래스에 @Bean을 이용해서 설정

```java
@Bean
public SqlSessionFactory sqlSessionFactory() throws Exception{
	SqlSessionFactoryBean sqlSessionFactory = new
	SqlSessionFactoryBean();
	sqlSEssionFactory.setDataSource(dataSource());
	return (SqlSessionFactory) sqlSessionFactory.getObject();
}
```

TimeMapper.java 인터페이스 작성

```java
package org.zerock.mapper;

import org.apache.ibatis.annotations.Select;

public interface TimeMapper {

	@Select("SELECT sysdate FROM dual")
	public String getTime();
}
```

TimeMapperTests.java 테스트파일 작성

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = { org.zerock.config.RootConfig.class })
@Log4j
public class TimeMapperTests {

	@Setter(onMethod_ = @Autowired)
	private TimeMapper timeMapper;
	
	@Test
	public void testGetTime() {
		log.info(timeMapper.getClass().getName());
		log.info(timeMapper.getTime());
	}
}

```

여기까지 완료하면 JAVA로는 연동을 확인할 수 있다.





### XML 매퍼와 같이 쓰기

mybatis를 통해 SQL처리시 어노테이션을 이용하는 것이 압도적 편리.. 그러나 길어지면 XML을 사용

XML작성시 XML파일의 위치와 XML파일에 지정하는 namespace속성이 중요

src/main/resource 하위에, 패키지명(. 기준)의 하위패키지들을 생성한다

org->zerock->mapper 순서로 하나씩 (한꺼번에 하면 에러발생할 수도 있음)

TimeMapper.xml 폴더를 작성한다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
	PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
	<mapper namespace="org.zerock.mapper.TimeMapper"> 
	
	<select id="getTime2" resultType="string">
	SELECT sysdate FROM dual
	</select>
	
	</mapper>
```

- mybatis는 Mapper 인터페이스와 XML을, **인터페이스 이름**과 namespace 속성 값을 갖고 판단한다.
- org.zerock.mapper 하위에 TimeMapper **인터페이스* * 가 존재하고, XML파일의 namespace가 동일하면, 이를 병합해서 처리한다.
- 다시말해 메소드 선언은 인터페이스 내에 존재하고, SQL에 대한 처리는 XML을 이용하는 방식
- 그렇다면 지금까지 했던 인터페이스와 implement이 구분지어진다는 것이 이에 대한 이유 때문인거네.

```java
	@Test
	public void testGetTime2() {
		log.info("getTime2");
		log.info(timeMapper.getTime2());
	}
```

해당 내용을 테스트파일에 추가 작성하여 테스트를 확인한다.



---
###### 7. 학습 내용에 대한 개인적인 총평
- 스프링의 설정(XML, JAVA)를 직접 코딩하면서 진행했다.
앞으로의 진행은 JAVA만을 통해서 진행하려고한다. 훨씬 간단할뿐더러 굳이 XML로 하면 헷갈릴 것 같기 때문이다.
처음에 아무것도모른채로 주먹구구식 설정을 했던 것이 좀 부끄럽기도 하다.
MVC패턴, CRUD, 이벤트 등을 통해 기능을 구현하고 HTML, CSS를 학습해 제대로 된 게시판을 구축할 것이다.
###### 8. 다음 학습 계획
- 백준 문제풀이
- 스프링 학습
- ft_printf 이슈 점검
- 평가진행하기
- 내용 정리