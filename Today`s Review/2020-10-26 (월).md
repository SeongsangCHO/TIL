

###### 1. 학습 날짜

- 2020 - 10- 26(월)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- OS

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- OS

---

###### 6. 상세 학습 내용

### CPU
- CPU는 기계어명령을 수행하는 중앙 처리장치
- 프로그램이 실행되면 PC에 현재 cpu에서 수행할 코드의 메모리 주소를 갖고 있게되는데 cpu가 주소의 기계어 명령을 하나 씩 수행함.

#### 기계어명령
- cpu내에서 수행되는 명령
  - `add` : 레지스터 두 값을 더해 저장
- 메모리 접근을 필요하는 명령
  - `Load`: 메모리에 있는 데이터를 cpu로 읽어들임
  - `Store` : cpu에서 계산된 결과를 메모리에 저장
- 입출력을 동반하는 명령


#### 사용자 프로그램이 수행되는 과정
- cpu, i/o작업의 반복으로 구성됨
- 사용자 프로그램이 cpu를 갖고 빠른 명령을 수행하는 것을 `CPU Burst`라하고 I/O요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계를 `I/O Burst`라 한다.
- I/O를 수행하고 다음번 I/O를 수행하기 까지 `CPU`를 갖고 명령을 수행하는 것을 CPU 버스트
- I/O요청후 완료되어 다시 `CPU 버스트로 돌아가기까지의 작업`을 `I/O버스트`라한다.
- `I/O 바운드 프로세스`는 I/O 요청 이 빈번해 CPU 버
스트가 짧게 나타나는 프로세스
- `CPU 바운드 프로세스`는 I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
-`I/O 바운드 프로세스`는 주로 사용자로부터 인터랙션을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램
- `CPU 바운드 프로세스`는 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램

i/o, cpu버스트가 일어나는 패턴이 프로그램마다 다르지만 동일한 시스템 내부에서 함께 실행되기에 이를 관리해주는 `CPU 스케쥴링`이 필요하다.


---

## CPU 스케쥴러

- 비선점형과 선점형방식이 있음
- 비선점형 : cpu를 획득한 프로세스가 스스로 반납하기 전까지 cpu를 뺏기지 않는 방법
- 선점형 : 프로세스의 cpu를 강제로 빼앗는 방법

---
## 디스패처
- cpu할당을 결정하면 이를 이양하는 작업이 필요한데, 선택된 프로세스가 cpu를 할당받고 작업을 수행할 수 있도록 환경설정하는 코드를 `디스패처`라고 함.
- 현재 수행중인 문맥을 pcb에 저장하고 새로운 프로세스의 문맥을 pcb로부터 복원하고 그 프로세스에게 cpu를 넘기는 과정을 수행
- **디스패처가 프로세스를 정지시키고 다른 프로세스에게 cpu를 전달하기까지 걸리는 시간을 디스패치 지연시간이라고 하고 이의 대부분은 문맥교환 오버헤드에 해당**

---
## 스케줄링 성능 평가

- 스케줄링 기법의 성능을 평가하기위해 사용되는 지표로는 cpu이용률, 처리량이 있고 이외에도 소요, 대기, 응답시간 등이 있음

- cpu가 휴면상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요 목표

---

## 스케줄링 알고리즘

### 1) 선입선출 FCFS(비선점형)
- 프로세스가 준비 큐에 도착한 시간 순대로 cpu를 할당하는 방식

- cpu버스트가 기이이인거 + 짧은거 여러개 있을 때 앞의 긴 작업을 모두가 기다려야해서 **평균 대기시간**이 길어지므로 상황에 따라 비효율적일 수 있음 => 콘보이 현상
- 프로세스마다 대기시간은 앞의 프로세스가 완료될 때 까지의 시간이고 평균 대기시간은 이를 프로세스 수로 나눈 시간이다.

### 2) 최단작업 우선 스케줄링 SJF (선점 또는 비선점으로 구현)
- cpu버스트가 가장 짧은 프로세스에게 먼저 cpu를 할당.
- 평균 대기시간을 가장 짧게하는 최적 알고리즘
- 더 짧은 버스트를 가진 프로세스 도착시 cpu를 빼앗아 할당
- 가장 긴 버스트를 가진 프로세스에게 cpu를 할당해주지 못하는 경우 ( 짧은 버스트가 계속해서 들어옴)를 **기아현상**이라고한다.

### 3) 우선순위 스케쥴링 (선점, 비선점으로 구현)
- 기아현상을 극복하기 위해 **aging**기법을 사용함
  - 기다리는 시간이 길어질수록 우선순위를 조금씩 높임.
- 준비큐에서 기다리는 프로세스 중 우선순위가 가장 높은 프로세스에게 cpu를 할당하는 방식

### 4) 라운드로빈
- 시분할 시스템 성질을 가장 잘 활용함
- 프로세스마다 한 번에 cpu를 사용할 수 있는 최대시간을 할당시켜 돌아가면서 수행할 수 있도록 함
- 할당시간이 너무 짧으면 프로세스 교체가 빈번하게 이루어져 문맥교환 오버헤드가 커짐
- 할당시간이 만료된 cpu회수할 때 타이머 인터럽트를 사용


각 스케쥴링 알고리즘마다 장점이 존재하며 상황에 맞는 알고리즘을 선택해야함. 어떤 알고리즘은 문맥교환이 너무 빈번하게 일어나고 어떤 것은 평균대기시간이 길어지고하는 문제가 발생함.


### 5) 멀티레벨 큐
- 준비큐를 여러개로 분할해 관리
- 어떤 줄에 있는걸 우선적으로 스케줄링할지, 어느 줄에 세워야할지하는 메커니즘 필요
- 큐 마다 스케줄링 알고리즘을 다르게 적용해 프로세스 성격에 맞게 관리할 수 있음
- 일반적으로 대화형작업을 위한 **전위 큐**, 계산 위주의 **후위 큐**로 분할하여 운영
- 큐에 대한 스케줄링도 필요. 어느 큐를 먼저 서비스할지를 정하는데 우선순위 방식을 사용함.

### 6) 멀티레벨 피드백 큐
- 멀티레벨 큐와 비슷하나 프로세스가 다른 큐로 이동할 수 있음
- **aging**기법을 구현가능, 낮은 우선순위에 있는 프로세스를 높은 우선순위 큐로 승격시키는 등.


### 7) 다중처리기 스케줄링
- cpu가 여러개인 시스템을 다중처리기 시스템이라 함.
- 여러 cpu가 프로세스를 적절히 나누어가져가서 작업할 수 있도록 부하균형을 적용해야함

### 8) 실시간 스케쥴링

- 작업마다 주어진 데드라인이 존재해 그 안에 반드시 작업을 처리해야함.
- hard, soft - real - time시스템이 있음
- 미사일 발사, 원자로제어등 지키지못하면 안되는 것을 hard
- 스트리밍 등이 soft 실시간 시스템

---

###### 7. 학습 내용에 대한 개인적인 총평

- OS 내용 학습, 스케줄러의 종류와 각 알고리즘 확인

###### 8. 다음 학습 계획

- OS