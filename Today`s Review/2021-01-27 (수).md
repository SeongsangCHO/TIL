

###### 1. 학습 날짜

- 2021 - 01 - 27(수)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- cpp02

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- cpp02

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

부동소수 → 고정소수 → 부동소수

float a; →      [X]           → float a;

고정소수란. 특정비트만큼 소수비트 수를 갖는 숫자 표현식 ⇒ fixed(8)

숫자를 표현할 때 정수 + 소수 ⇒ 7.625 ⇒ 1011.[0111 0000]

42.421999817f ⇒ 왜? 42.42인데 왜 뒤에 붙어?

⇒ 부동소수의 계산방식때문에 생김.

⇒ 부동소수는 32비트로 엄청난 수를 표현한다. 그래서 근사값으로 계산을 하게되어서 오차발생함.

⇒ int 32= > +-21억 (42억) float 훨씬 더 많이 표현 가능한것도 근사값으로 계산하기때문. 1010101111 ⇒ 2^n*1 + 2^n-1 * 1 이 방식이 아니라

지수부, 가수부를 나눠서 근사값으로 계산하는 방식으로 인해서 많은 수를 표현할 수 있는 것.

32비트를 짜리를 8비트소수로 사용, 정수 표현 가능 범위는 24비트로 줌. 왜 와이?

⇒ 8비트 고정이라서. 아예 소수의 영역임.

[24 + 8] // 잘 계산해야하는데. 8비트는 어떻게 보장할거냐?

바로 비트연산으로. 어떻게?

예제 들어감니다

10진수 : 42.421999817

2진수 : 101010.01101011 10000101000000000000010010000111101001

101010.01101011 ⇒ 42.4199..

10101001101011.000010000101110000...

10859.0000100010111 ⇒ 반올림.

10860.0 ⇒ 101010.01101100 ⇒ 소수점 8자리 보장완료 24+8로 표현한 고정소수점표현방식

요거를 다시 부동소수로 바꿔보자

float(42.421875) ⇒ 42.4219

지수 + 가수 ⇒ 부동소수 ⇒ 많은 수를 표현할 수 있도록하는 숫자 표현방법.

1, 8, 23 ⇒ 32비트 숫자 표현= > 범위 엄청남.. ⇒ 32비트 42억..

⇒부동소수점표현 38 + 38 ⇒ 32비트 유한 ⇒ 엄청나게 근사값.. ⇒ 정확한 값 표현X

고정소수점. ⇒ 특정비트를 소수점으로 갖는 숫자표현방법. (fixed(8)) ⇒ 소수점자리를 8비트 쓰겠다.

나머지는 정수로 표현

float 32비트 ⇒ 24를 정수표현, 8비트만 소수표현.

100000000 = value / 256

100 ⇒ 10 , 10으로 나눈다

10.0 ⇒ 10진수라서 소수점밀려면 10으로 나누는거

10 2진수는 2로 나누는거

100 ⇒ 4 ,2로만들래 /2

10.0 ⇒ 2

42.42f ⇒ 부동소수점으로 표현된 값을 8비트를 소수비트로 갖는 고정소수로 표현해서 부동소수 또는 정수로 변환하기

고정소수점 ⇒  24(정수) 8(소수) ⇒ fixed(8)

10.0 ⇒ 100  10.0 x10 ⇒10진수

101010.0110 ⇒ 2를 곱함. ⇒ 8자리 256, (1<<8)

42.42f는 42.421999817 인가 그럼 이를 2진수로 변환하면

1. 0110 1011 * 256( 1 << 8) ..... 임 ⇒ 10101001101011 . 0000x...... (256배

여기서 8비트를 소수로 보장해야하니 256배, 좌측 8비트연산을 수행해서 정수로만듬

101010 01101011.00....으로 만들고 반올림 수행 ⇒ 10859.5 ⇒ 10860

101010.01101100⇒ 10860

이를 256으로 나누면 101010.01101100이므로 고정소수로 표현된 값은 42.421875가 됨

이를 다시 부동소수로 표현하려면 float 타입캐스팅 수행 ⇒ 42.4219 출력

# 고정소수점 만드는 과제네.

float형을 32비트 정수로 만들고 이를 24비트를 정수부분, 8비트를 소수를 갖게  하는 고정소수점방식으로 표현해야함

- float에 256배, 8비트 좌측쉬프트연산으로 소수자리 보장한후,

https://www.aladin.co.kr/shop/ebook/wPreviewViewer.aspx?itemid=102969463

https://bab2min.tistory.com/183

자 고정소수점 데이터 타입 Fixedp을 정의해봅시다. 32비트 정수에서 상위 24비트는 정수부분을 표현하는데 쓰고, 하위 8비트를 소수부분을 표현하는데 이용해봅시다.

즉 임의의 32비트 정수 n이 n / 256 을 나타내도록 정의하자는 것입니다.

https://t1.daumcdn.net/cfile/tistory/16314C4D5076839E0C

그러면 어떤 수 x를 Fixedp로 표현하기 위해선 256을 곱하면 됩니다. x가 정수라면 간단하게 x << 8이 되는거지요.

# 부동소수오차

- 무한개의 수를 유한개 비트로 표현하기 위해서 근사값으로 계산하는데 이때 오차가 발생할 수 있음
- std::cout 기본정밀도 6. 모든 부동 소수점 숫자는 6자리만 유의하다 생각해서 이후 잘라냄.
- 

# 고정소수, 부동소수

https://gsmesie692.tistory.com/94

- 고정 소수 = 7.625라는 수를 2진수로 변환
  - 111.101을 [부호비트 + 정수부.소수부로 표현함]
    - [0]000111.1010000] ⇒ 양수 비트 0
- 부동소수 = 그대로 2진수 값을 넣지않고 몇가지 과정 추가 (32비트 또는 64비트로 실수를 저장함)
  - 1.xxxxxx... * 2^n
  - 정수부에 1만 남을 때 까지 소수점을 왼쪽으로 이동시키고 이동 칸 만큼 n자리에 넣음
  - 111.101 ⇒ 1.11101 * 2^2 ⇒ 좌로 2번 이동 (111을 1.11로 만들기 위해서)
    - 1.[111] 인데 맨왼쪽은 1고정으로 히든 비트라고도 함 무조건 1임
  - 32비트 예로 들면 1비트는 부호, 8비트는 지수부, 나머지 23비트는 가수부(fraction)
    - 23자리에는 소수점 우측에 있는 숫자를 왼쪽부터 채우고 남는건 0으로 채움
    - 23[1110100000....] 이겠찌
    - 지수부에는 2^n에서 n의 수, 2를 2진수로 바꾼 10을 넣음
      - 그냥 넣는게 아닌 bias라는 지정 값 더한 뒤 넣음
      - 2 + 127 ⇒ 129를 2진수로 바꾼 10000001이 지수에 들어감
    - 최종
      - 0[10000001]111010000000....

# roundf

- ```
  float roundf ( float arg)
  ```

  - arg를 0에서 반올림 해서 가장 가까운 정수값(부동 소수점 형식)으로 계산

# 함수 뒤에 붙는 const

- 바로 이 함수 안에서는 어떤 변수도 바꿀 수 없음(mutable은 예외)를 뜻한다.
- getter에 많이 사용

```jsx
bool IsNotZero() const {
      return num != 0;
   }
```

# 이제부터 캐노니컬 폼 작성해야함.

- 기본 생성자
- 복사 생성자
- 대입연산자 오버로딩
- 소멸자

# Ex00

- ex00/ Fixed.class.hpp and Fixed.class.cpp, or Fixed.hpp and Fixed.cpp, or Fixed.h and [Fixed.cc](http://Fixed.cc). Pick one, I don’t care unless it’s stupid.

- 부동소수 만들라는거 같은데

- private members

  - 부동 소수 값을 저장할 int
  - static const int = 소수 비트 수를 저장할 상수 정수 = 8글자 항상

- public members

  - fixedPointValue를 0으로 초기화하는 기본생성자
  - 소멸자
  - 복사생성자
  - 대입연산자 오버라이딩
  - `getRawBits(void) const` 멤버함수 ⇒ fixed point value의 raw value를 반환한다
  - `setRawBits(int const raw)` 멤버함수 ⇒ fixed point value의 raw value를 set한다

  ```jsx
  #include <iostream>
  int main( void ) {
  
  	Fixed a; //기본생성자
  	Fixed b( a ); // 복사생성자
  	Fixed c; // 기본 생성자
  	c = b; // 대입연산자 오버로딩
  	std::cout << a.getRawBits() << std::endl;
  	std::cout << b.getRawBits() << std::endl;
  	std::cout << c.getRawBits() << std::endl;
  	return 0;
  
  }
  ```

  ```jsx
  $> clang++ -Wall -Wextra -Werror Fixed.class.cpp main.cpp
  $> ./a.out
  Default constructor called
  Copy constructor called
  Assignation operator called // <-- This line may be missing depending on your implementation
  getRawBits member function called
  Default constructor called
  Assignation operator called
  getRawBits member function called
  getRawBits member function called
  0
  getRawBits member function called
  0
  getRawBits member function called
  0
  Destructor called
  Destructor called
  Destructor called
  $>
  ```

  # ex01

  ### << 연산자 오버로딩

  https://m.blog.naver.com/PostView.nhn?blogId=kks227&logNo=60205596757&proxyReferer=https:%2F%2Fwww.google.com%2F

  <<연산의 반환은 ostream이다. cout<<1 <<2 했을때  1을 출력하고 cout << 2가 남아야해서 반환이 있어야함.

  객체이름을 출력할 때 재정의가 필요한데 형식은

  ```jsx
  std::ostream &operator<<(std::ostream &out, const Fixed &f)
  {
    std::cout << f.toFloat();
    return (out);
  }
  ```

  - ex01/Fixed.cpp, Fixed.hpp 제출

  - roundf 함수 사용 <cmath>

  - 생성자 역할

    - 상수 정수를 매개변수로 사용하고 이를 상응하는 fixed(8) 고정소수점 값 으로 반환.
      - 소수 비트 값은 ex00과 같이 초기화 함.
    - 상수 부동소수점을 매개변수로 사용하고 이를 상응하는 fixed(8) 포인트 값으로 변환하는 생성자
      - 소수 비트 값은 "
    - `toFloat(void) const` 고정 소수점을 부동 소수로 변환
    - `toInt(void) const` fixed point value를 integer value로 변경

  - 헤더, 소스에 다음 함수 오버로드를 추가해야함

    - `<<` 연산자 오버로드, 고정 소수점 값의 부동 소수 표현을 매개 변수 출력 스트림에 삽입해야함.

    ```jsx
    #include <iostream>
    int main( void ) {
    	Fixed a;
    	Fixed const b( 10 );
    	Fixed const c( 42.42f );
    	Fixed const d( b );
    	a = Fixed( 1234.4321f );
    	std::cout << "a is " << a << std::endl;
    	std::cout << "b is " << b << std::endl;
    	std::cout << "c is " << c << std::endl;
    	std::cout << "d is " << d << std::endl;
    	std::cout << "a is " << a.toInt() << " as integer" << std::endl;
    	std::cout << "b is " << b.toInt() << " as integer" << std::endl;
    	std::cout << "c is " << c.toInt() << " as integer" << std::endl;
    	std::cout << "d is " << d.toInt() << " as integer" << std::endl;
    	return 0;
    }
    ```

    ```jsx
    $> clang++ -Wall -Wextra -Werror Fixed.class.cpp main.cpp
    $> ./a.out
    Default constructor called
    Int constructor called
    Float constructor called
    Copy constructor called
    Assignation operator called
    Float constructor called
    Assignation operator called
    Destructor called
    a is 1234.43
    b is 10
    c is 42.4219
    d is 10
    a is 1234 as integer
    b is 10 as integer
    c is 42 as integer
    d is 10 as integer
    Destructor called
    Destructor called
    Destructor called
    Destructor called
    $>
    ```

    

---

###### 7. 학습 내용에 대한 개인적인 총평

- cpp02 구현
- 고정소수점 -> 부동소수점으로 변환

###### 8. 다음 학습 계획

- cpp03