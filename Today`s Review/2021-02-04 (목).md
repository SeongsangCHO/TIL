

###### 1. 학습 날짜

- 2021 - 02 - 04(목)

---

###### 2. 학습시간

- 10:00 ~ 18:00

---

###### 3. 학습 범위 및 주제

- Cpp07

---

###### 4. 동료 학습 방법 

- daelee, taelee, jehong, mihykim

---

###### 5. 학습 목표 

- Cpp07

---

###### 6. 상세 학습 내용

- 코드작성시간 :  시간

템플릿 자료형

# 템플릿.

- 함수의 기능은 명확- 자료형은 모호-
- 템플릿을 사용하면 다른 자료형 함수를 만들 필요없이 하나로 사용하면 됨.

예제

```jsx
template <typename T>
T sum(T a, T b){
    return a + b;
}

출처: <https://blockdmask.tistory.com/43> [개발자 지망생]
```

ex00

- 함수 템플릿을 사용해서 다음을 구현하라
- swap: 2개의 인자들을 스왑. 아무것도 리턴하지마셈
- min : 2개인자를 비교해서 작은 것을 반환. 2개인자가 같다면, 2번째 것을 반환
- max : 2개인자 중 큰 것을 반환하고 같다면 2번째를 반환하라.

템플릿은 반드시 헤더파일 안에 정의되어야함.  main.cpp를  테스트와 함께 포함해서 제출해라.

```jsx
::은 namespace에 접근할 수 있는 범위.
int main( void ) {
	int a = 2;
	int b = 3;
	::swap( a, b );
	std::cout << "a = " << a << ", b = " << b << std::endl;
	std::cout << "min( a, b ) = " << ::min( a, b ) << std::endl;
	std::cout << "max( a, b ) = " << ::max( a, b ) << std::endl;
	std::string c = "chaine1";
	std::string d = "chaine2";
	::swap(c, d);
	std::cout << "c = " << c << ", d = " << d << std::endl;
	std::cout << "min( c, d ) = " << ::min( c, d ) << std::endl;
	std::cout << "max( c, d ) = " << ::max( c, d ) << std::endl;
	return 0;
}

a = 3, b = 2
min(a, b) = 2
max(a, b) = 3
c = chaine2, d = chaine1
min(c, d) = chaine1
max(c, d) = chaine2
```

# ex01 Iter

- 함수 템플릿 iter를 작성해라 이건 3개의 파라미터를 받고 반환은 없다.
- 1번째 인자 : 배열의 주소
- 2번째 인자 : 배열의 길이
- 3번째인자 : 배열의 각 원소로부터 호출되는 함수?
- 함수 템플릿 iter가 모든 유형의 배열 또는 인스턴스화된 함수템플릿을 세 번째 매개 변수로 사용함을 입증하는 파일을 만들어라..
- 메인에서 iter를 호출해서 함수포인터로 배열에 있는 내용을 전체 출력하도록 만듦.

```jsx
template<typename T>
void iter(배열 주소, 배열 길이, 원소로부터 호출되는 함수){
//T &array, int length, void (*func)(T element))
}
```

# ex02 Array

### 클래스템플릿

- 정의와 선언을 같이해주어야하지만 분리할 수도 있음
  - https://www.sapphosound.com/archives/389
- 정의된 타입 이름은 클래스의 선언에서 임의의 타입으로 사용할 수 있습니다.

```jsx
template <typename T>

class Data

{

private:

    T data_;

public:

    Data(T dt);

    data(T dt);

    T get_data();

};

템플릿 클래스는 Data<T> 라고 이제 쓰임

//cpp
<https://pacs.tistory.com/entry/C-%ED%95%A8%EC%88%98-%ED%85%9C%ED%94%8C%EB%A6%BF%EA%B3%BC-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%9C%ED%94%8C%EB%A6%BF-Function-template-Class-template>
template <typename T>
Data<T>::Data(T d){ // 생성자
}
```

- Array.hpp, or Array.tpp, or Array.h, or anything that makes sens, plus anything necessary to build an executable, and a Makefile
- 템플릿 클래스 Array를 작성해라. 이건 type T의 원소들을 포함하고 있다, 그리고 다음과 같은 행동을 따른다.
- 생성자는 파라미터 없이. 빈 배열을 생성하라.
- unsigned int 를 인자로 받는 생성자 : n개의 원소를 갖는 배열을 생성해라.
- int *a = new int(); 그리고 *a를 한번 출력해보는 것이 팁임.
- 복사와 대입연산자 생성자를 작성해라 두가지 케이스에 대해서는, 복사, 할당 후 다른 배열에 영향을 주면 안됨. (깊은 복사)
- 넌 반드시 new[]로 할당해야한다. 넌, 할당 보호를 하면 안돼? 너의 코드는 반드시 할당되지 않은 메모리에 접근하면 안됨.
- 원소들은 operator[]에 의해 접근되어야해
- operator[]으로 원소접근할 때 만약 limits를 넘어서면 std::exception으로 던져야한다.
- 멤버함수인 `size` 는 배열의 원소 숫자를 반환한다. 이 멤버함수는 아무 파라미터도 받지않으며 아무것도 수정하지 않는다.

---

###### 7. 학습 내용에 대한 개인적인 총평

- Cpp07. 템플릿에 대해 학습.

###### 8. 다음 학습 계획

- cpp08