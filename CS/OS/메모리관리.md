## 메모리관리



### 1. 주소바인딩

프로그램이 메모리에 적재되면 주소공간이 생성되는데 이를 **논리적 주소**라 한다.

**물리적 주소**는 실제로 물리적 메모리에 올라가는 위치를 뜻한다.



프로세스가 실행되기 위해선 먼저 물리적 메모리에 프로그램이 올라가 있어야하고, CPU의 기계어 명령을 수행하기 위해 **논리적 주소**를 통해 메모리 참조를 하면 **해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인**해야한다.



프로세스의 논리적 주소 = 물리적 주소로 연결시키는 작업을 **주소 바인딩**이라 한다.



주소 바인딩의 방식은 세가지로 분류될 수 있는데 물리적 메모리의 주소가 결정되는 시기에 따른다.



- 컴파일 타임 바인딩 : 물리적 메모리주소가 프로그램을 **컴파일**할 때 결정, 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 결정, 메모리 위치 변경할 때 컴파일 다시해야함. 잘 사용 안함
- 로드 타임 바인딩 : 프로그램 실행이 **시작될 때** 물리적 메모리주소가 결정되는 방식. 프로그램 종료까지 물리적 메모리상 위치가 고정
  - Loader이란 프로그램을 메모리에 적재시키는 프로그램
- 실행시간 바인딩 : 프로그램 실행 이후에도 메모리 주소가 변경될 수 있음 CPU가 주소 참조마다 **주소 매핑 테이블**을 이용해 물리 메모리 위치를 점검
  - 실행시간 바인딩 방식을 위해서 **기준 레지스터, 한계레지스터, MMU(메모리 관리 유닛)**의 하드웨어가 있어야함
  - MMU : 논리적 주소를 물리적 주소로 매핑해주는 HW

<br>

#### MMU 기법

주소변환을 수행하는 MMU기법

프로그램의 주소가 물리적 메모리에 연속적으로 적재되는 것을 가정

시작주소만 알면 주소변환을 쉽게할 수 있음

논리적 주소만 다루고 물리적 주소를 알 필요도 없음

CPU가 프로세스의 논리적 주소를 참조하려할 때 **MMU는 그 주소값 + 기준 레지스터 값을 하여 물리적 주소값을 얻어낸다.** (기준 레지스터 == 재배치 레지스터 (프로세스의 물리적 메모리 시작 주소를 가짐))

프로세스는 자신만의 고유 주소공간이 있어서 동일한 주소값이라 해도 각 프로세스마다 서로 다른 내용을 담고 있음

문맥교환으로 PS가 바뀔 때마다 **재배치 레지스터 값을 그 프로세스에 해당되는 값으로 재 설정**

<br>

##### CPU가 요청한 논리적 주소값 + 재배치 레지스터 값이 프로세스 주소공간을 벗어나는 경우?

메모리보안이 이뤄지지 않아 다른 프로그램 영역을 침범할 수 있음.

이를 방지하기 위한 **한계 레지스터**



- 한계레지스터 : ps가 주소공간을 넘어서는 메모리참조를 하는지 체크하는 용도, 그 프로세스의 **크기**를 담고 있음

![image](https://user-images.githubusercontent.com/55486644/97109064-88646e00-1714-11eb-846a-0e8458f0826b.png)



1. CPU가 요청한 ps의 논리적 주소값이 한계 레지스터의 값보다 작은지 확인
2. 작으면 논리적 주소값 + 재배치 레지스터 값을 더해 물리적 주소를 구하여 해당 메모리 위치에 접근

2번에서 논리적 주소값이 크다면 다른 프로세스 주소에 접근하려는 시도이므로 **트랩**을 발생시켜 프로세스를 강제종료시킴



### 7-1 :fallen_leaf: 주소 바인딩　`secho`

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `___ __`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `___ ___`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.



2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.




<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `논리적 주소`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `물리적 메모리`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해서  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.



2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

프로세스의 논리적 주소 = 물리적 주소로 연결시키는 작업을 **주소 바인딩**이라 한다.

컴파일 타임 바인딩, 로드 타임 바인딩, 실행시간 바인딩

![image](https://user-images.githubusercontent.com/55486644/97109874-29552800-1719-11eb-9a32-d6eff02b22f7.png)

- 컴파일 타임 바인딩: 프로그램을 컴파일할 때 물리적 메모리주소가 결정됨 (물리적 메모리주소 === 논리적(프로그램 )메모리 주소) 
  - 프로그램 내 주소인 0번 10번 20번 ..의 논리적 주소가 물리적 주소로 그대로 결정됨
  - 이미 다른 프로세스에서 사용하고 있는 메모리주소가 있을 수 있기에 이 방법은 현재 거의 안씀 - 아두이노같은 경우에는 사용(한 프로그램만 돌아감)
- 로드 타임 바인딩 : 프로그램 **실행이 시작될 때** 물리적 주소가 결정
  - 프로그램 종료까지 물리적 메모리 위치 고정
  - 실행될 때마다 주소가 변경되므로 프로그램 내의 메모리 주소 전체를 어디에 로딩되는지에 따라 주소를 전부 다 바꿔주어야함. -> 메모리 로딩시간이 긺 -> 안씀
- 실행시간 바인딩 : 실행 이후, 메모리 주소가 변경될 수 있음
  - 기준, 한계, MMU 하드웨어의 지원으로 가능
  - load타임과 같은데  물리적 메모리에서 HW가 메모리 주소를 매핑시켜줌

</div>
</details>
<br><br>